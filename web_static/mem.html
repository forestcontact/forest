<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mem API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mem</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># type: ignore
# pylint: skip-file
# Copyright 2017-2021 Ilia Daniher
# Copyright 2013-2018 Mark Stover
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
# 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import errno
import os
import stat
import time
import sys
import logging

from forest.fuse import FUSE, FuseOSError, Operations, get_caller, LoggingMixIn

BLOCK_SIZE = 4096


class Property(dict):
    def __init__(
        self,
        st_mode=493,
        st_nlink=0,
        st_size=0,
        st_ctime=0,
        st_mtime=0,
        st_atime=0,
        st_gid=0,
        st_uid=0,
        st_blocks=0,
    ):
        self.st_mode = st_mode
        self.st_nlink = st_nlink
        self.st_size = st_size
        self.st_ctime = st_ctime
        self.st_mtime = st_mtime
        self.st_atime = st_atime
        self.st_gid = os.getgid()
        self.st_uid = os.getuid()
        self.st_blocks = st_blocks


class Directory(object):
    def __init__(self, files, directories, properties):
        self.files = files
        self.directories = directories
        self.properties = properties


class File(object):
    def __init__(self, data, properties):
        self.data = data
        self.properties = properties


class Memory(LoggingMixIn, Operations):
    def __unicode__(self):
        return str(self)

    def __init__(self, livelock=None, logqueue=None) -&gt; None:
        self.filesystem = {}
        self.fd = 0
        now = time.time()
        self.logqueue = logqueue
        self.livelock = livelock
        self.filesystem[&#34;/&#34;] = Directory(
            files={},
            directories={},
            properties=Property(
                st_mode=stat.S_IFDIR | 493,
                st_nlink=2,
                st_size=0,
                st_ctime=now,
                st_mtime=now,
                st_atime=now,
                st_gid=os.getgid(),
                st_uid=os.getuid(),
            ),
        )

    def init(self, path) -&gt; None:
        if self.livelock is not None:
            self.livelock.release()

    def chmod(self, path, mode):
        item = self.get_file(path)
        if not item:
            item = self.get_dir(path)
        if item:
            item.properties.st_mode &amp;= 258048
            item.properties.st_mode |= mode
        return 0

    def chown(self, path, uid, gid):
        item = self.get_file(path)
        if not item:
            item = self.get_dir(path)
        if item:
            item.properties.st_uid = uid
            item.properties.st_gid = gid
        return 0

    def create(self, path, mode):
        filename = path.split(&#34;/&#34;)[-1]
        dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
        dirobj = self.get_dir(dirname)
        now = time.time()
        dirobj.files[filename] = File(
            data=bytearray(),
            properties=Property(
                st_mode=stat.S_IFREG | mode,
                st_nlink=1,
                st_size=0,
                st_ctime=now,
                st_mtime=now,
                st_atime=now,
            ),
        )
        self.fd += 1
        return self.fd

    def getattr(self, path, fh=None):
        st = self.get_file(path)
        if not st:
            st = self.get_dir(path)
        if not st:
            raise FuseOSError(errno.ENOENT)
        return st.properties.__dict__

    def getxattr(self, path, name, position=0):
        st = self.get_file(path)
        if not st:
            st = self.get_dir(path)
        attrs = st.properties.get(&#34;attrs&#34;, {})
        try:
            return attrs[name]
        except KeyError:
            return b&#34;&#34;

    def listxattr(self, path):
        st = self.get_file(path)
        if not st:
            st = self.get_dir(path)
        attrs = st.properties.get(&#34;attrs&#34;, {})
        return list(attrs.keys())

    def mkdir(self, path, mode):
        path = path.rstrip(&#34;/&#34;)
        newdir = path.split(&#34;/&#34;)[-1]
        dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
        dirobj = self.get_dir(dirname)
        now = time.time()
        dirobj.directories[newdir] = Directory(
            files={},
            directories={},
            properties=Property(
                st_mode=stat.S_IFDIR | mode,
                st_nlink=2,
                st_size=0,
                st_ctime=now,
                st_mtime=now,
                st_atime=now,
            ),
        )
        dirobj.properties.st_nlink += 1

    def open(self, path, flags):
        logging.debug(&#34;opening&#34;, get_caller())
        self.fd += 1
        return self.fd

    def read(self, path, size, offset, fh):
        fileobj = self.get_file(path)
        return bytes(fileobj.data[offset : (offset + size)])

    def readdir(self, path, fh):
        st = self.get_dir(path)
        caller_info = get_caller()
        return [&#34;.&#34;, &#34;..&#34;] + [x for x in st.files] + [x for x in st.directories]

    def readlink(self, path):
        st = self.get_file(path)
        return st.data

    def removexattr(self, path, name):
        st = self.get_file(path)
        if not st:
            st = self.get_dir(path)
        attrs = st.properties.get(&#34;attrs&#34;, {})
        try:
            del attrs[name]
        except KeyError:
            pass

    def rename(self, old, new):
        oldname = old.split(&#34;/&#34;)[-1]
        newname = new.split(&#34;/&#34;)[-1]
        parentname = &#34;/&#34;.join(old.split(&#34;/&#34;)[:-1])
        parentobj = self.get_dir(parentname)
        if self.get_file(old):
            parentobj.files[newname] = parentobj.files.pop(oldname)
        elif self.get_dir(old):
            parentobj.directories[newname] = parentobj.directories.pop(oldname)

    def rmdir(self, path):
        parentname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
        parentobj = self.get_dir(parentname)
        dirname = path.split(&#34;/&#34;)[-1]
        parentobj.directories.pop(dirname)
        parentobj.properties.st_nlink -= 1

    def setxattr(self, path, name, value, options, position=0):
        st = self.get_file(path)
        if not st:
            st = self.get_dir(path)
        attrs = st.setdefault(&#34;attrs&#34;, {})
        attrs[name] = value

    def statfs(self, path):
        return dict(f_bsize=BLOCK_SIZE, f_blocks=4096, f_bavail=4096)

    def symlink(self, target, source):
        targetname = target.split(&#34;/&#34;)[-1]
        targetdir = &#34;/&#34;.join(target.split(&#34;/&#34;)[:-1])
        targetdirobj = self.get_dir(targetdir)
        now = time.time()
        targetdirobj.files[targetname] = File(
            data=source,
            properties=Property(
                st_mode=stat.S_IFLNK,
                st_nlink=1,
                st_size=len(source),
                st_ctime=now,
                st_mtime=now,
                st_atime=now,
                st_blocks=len(source) // BLOCK_SIZE,
            ),
        )

    def truncate(self, path, length, fh=None):
        st = self.get_file(path)
        st.data = st.data[:length]
        st.properties.st_size = length
        st.properties.st_blocks = length // BLOCK_SIZE

    def unlink(self, path):
        dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
        filename = path.split(&#34;/&#34;)[-1]
        st = self.get_dir(dirname)
        st.files.pop(filename)

    def utimens(self, path, times=None):
        now = time.time()
        (atime, mtime) = times if times else (now, now)
        st = self.get_file(path)
        st.properties.st_atime = atime
        st.properties.st_mtime = mtime

    def write(self, path, data, offset, fh):
        st = self.get_file(path)
        st.data[offset:] = data
        st.properties.st_size = len(st.data)
        st.properties.st_blocks = len(st.data) // BLOCK_SIZE
        return len(data)

    def get_file(self, path):
        if path[-1] == &#34;/&#34;:
            return None
        else:
            patharray = path.split(&#34;/&#34;)
            filename = patharray.pop()
            dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
            location = self.get_dir(dirname)
            if location and filename in location.files:
                return location.files[filename]
            return None

    def get_dir(self, path):
        path = path.rstrip(&#34;/&#34;)
        patharray = path.split(&#34;/&#34;)
        if len(patharray) &lt;= 1:
            return self.filesystem[&#34;/&#34;]
        patharray.pop(0)
        location = self.filesystem[&#34;/&#34;]
        while patharray:
            dirpath = patharray.pop(0)
            if dirpath in location.directories:
                location = location.directories[dirpath]
            else:
                return None
        return location


if __name__ == &#34;__main__&#34;:
    import sys

    fuse = FUSE(Memory(), sys.argv[1], foreground=True, debug=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mem.Directory"><code class="flex name class">
<span>class <span class="ident">Directory</span></span>
<span>(</span><span>files, directories, properties)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Directory(object):
    def __init__(self, files, directories, properties):
        self.files = files
        self.directories = directories
        self.properties = properties</code></pre>
</details>
</dd>
<dt id="mem.File"><code class="flex name class">
<span>class <span class="ident">File</span></span>
<span>(</span><span>data, properties)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class File(object):
    def __init__(self, data, properties):
        self.data = data
        self.properties = properties</code></pre>
</details>
</dd>
<dt id="mem.Memory"><code class="flex name class">
<span>class <span class="ident">Memory</span></span>
<span>(</span><span>livelock=None, logqueue=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class should be subclassed and passed as an argument to FUSE on
initialization. All operations should raise a FuseOSError exception on
error.</p>
<p>When in doubt of what an operation should do, check the FUSE header file
or the corresponding system call man page.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Memory(LoggingMixIn, Operations):
    def __unicode__(self):
        return str(self)

    def __init__(self, livelock=None, logqueue=None) -&gt; None:
        self.filesystem = {}
        self.fd = 0
        now = time.time()
        self.logqueue = logqueue
        self.livelock = livelock
        self.filesystem[&#34;/&#34;] = Directory(
            files={},
            directories={},
            properties=Property(
                st_mode=stat.S_IFDIR | 493,
                st_nlink=2,
                st_size=0,
                st_ctime=now,
                st_mtime=now,
                st_atime=now,
                st_gid=os.getgid(),
                st_uid=os.getuid(),
            ),
        )

    def init(self, path) -&gt; None:
        if self.livelock is not None:
            self.livelock.release()

    def chmod(self, path, mode):
        item = self.get_file(path)
        if not item:
            item = self.get_dir(path)
        if item:
            item.properties.st_mode &amp;= 258048
            item.properties.st_mode |= mode
        return 0

    def chown(self, path, uid, gid):
        item = self.get_file(path)
        if not item:
            item = self.get_dir(path)
        if item:
            item.properties.st_uid = uid
            item.properties.st_gid = gid
        return 0

    def create(self, path, mode):
        filename = path.split(&#34;/&#34;)[-1]
        dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
        dirobj = self.get_dir(dirname)
        now = time.time()
        dirobj.files[filename] = File(
            data=bytearray(),
            properties=Property(
                st_mode=stat.S_IFREG | mode,
                st_nlink=1,
                st_size=0,
                st_ctime=now,
                st_mtime=now,
                st_atime=now,
            ),
        )
        self.fd += 1
        return self.fd

    def getattr(self, path, fh=None):
        st = self.get_file(path)
        if not st:
            st = self.get_dir(path)
        if not st:
            raise FuseOSError(errno.ENOENT)
        return st.properties.__dict__

    def getxattr(self, path, name, position=0):
        st = self.get_file(path)
        if not st:
            st = self.get_dir(path)
        attrs = st.properties.get(&#34;attrs&#34;, {})
        try:
            return attrs[name]
        except KeyError:
            return b&#34;&#34;

    def listxattr(self, path):
        st = self.get_file(path)
        if not st:
            st = self.get_dir(path)
        attrs = st.properties.get(&#34;attrs&#34;, {})
        return list(attrs.keys())

    def mkdir(self, path, mode):
        path = path.rstrip(&#34;/&#34;)
        newdir = path.split(&#34;/&#34;)[-1]
        dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
        dirobj = self.get_dir(dirname)
        now = time.time()
        dirobj.directories[newdir] = Directory(
            files={},
            directories={},
            properties=Property(
                st_mode=stat.S_IFDIR | mode,
                st_nlink=2,
                st_size=0,
                st_ctime=now,
                st_mtime=now,
                st_atime=now,
            ),
        )
        dirobj.properties.st_nlink += 1

    def open(self, path, flags):
        logging.debug(&#34;opening&#34;, get_caller())
        self.fd += 1
        return self.fd

    def read(self, path, size, offset, fh):
        fileobj = self.get_file(path)
        return bytes(fileobj.data[offset : (offset + size)])

    def readdir(self, path, fh):
        st = self.get_dir(path)
        caller_info = get_caller()
        return [&#34;.&#34;, &#34;..&#34;] + [x for x in st.files] + [x for x in st.directories]

    def readlink(self, path):
        st = self.get_file(path)
        return st.data

    def removexattr(self, path, name):
        st = self.get_file(path)
        if not st:
            st = self.get_dir(path)
        attrs = st.properties.get(&#34;attrs&#34;, {})
        try:
            del attrs[name]
        except KeyError:
            pass

    def rename(self, old, new):
        oldname = old.split(&#34;/&#34;)[-1]
        newname = new.split(&#34;/&#34;)[-1]
        parentname = &#34;/&#34;.join(old.split(&#34;/&#34;)[:-1])
        parentobj = self.get_dir(parentname)
        if self.get_file(old):
            parentobj.files[newname] = parentobj.files.pop(oldname)
        elif self.get_dir(old):
            parentobj.directories[newname] = parentobj.directories.pop(oldname)

    def rmdir(self, path):
        parentname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
        parentobj = self.get_dir(parentname)
        dirname = path.split(&#34;/&#34;)[-1]
        parentobj.directories.pop(dirname)
        parentobj.properties.st_nlink -= 1

    def setxattr(self, path, name, value, options, position=0):
        st = self.get_file(path)
        if not st:
            st = self.get_dir(path)
        attrs = st.setdefault(&#34;attrs&#34;, {})
        attrs[name] = value

    def statfs(self, path):
        return dict(f_bsize=BLOCK_SIZE, f_blocks=4096, f_bavail=4096)

    def symlink(self, target, source):
        targetname = target.split(&#34;/&#34;)[-1]
        targetdir = &#34;/&#34;.join(target.split(&#34;/&#34;)[:-1])
        targetdirobj = self.get_dir(targetdir)
        now = time.time()
        targetdirobj.files[targetname] = File(
            data=source,
            properties=Property(
                st_mode=stat.S_IFLNK,
                st_nlink=1,
                st_size=len(source),
                st_ctime=now,
                st_mtime=now,
                st_atime=now,
                st_blocks=len(source) // BLOCK_SIZE,
            ),
        )

    def truncate(self, path, length, fh=None):
        st = self.get_file(path)
        st.data = st.data[:length]
        st.properties.st_size = length
        st.properties.st_blocks = length // BLOCK_SIZE

    def unlink(self, path):
        dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
        filename = path.split(&#34;/&#34;)[-1]
        st = self.get_dir(dirname)
        st.files.pop(filename)

    def utimens(self, path, times=None):
        now = time.time()
        (atime, mtime) = times if times else (now, now)
        st = self.get_file(path)
        st.properties.st_atime = atime
        st.properties.st_mtime = mtime

    def write(self, path, data, offset, fh):
        st = self.get_file(path)
        st.data[offset:] = data
        st.properties.st_size = len(st.data)
        st.properties.st_blocks = len(st.data) // BLOCK_SIZE
        return len(data)

    def get_file(self, path):
        if path[-1] == &#34;/&#34;:
            return None
        else:
            patharray = path.split(&#34;/&#34;)
            filename = patharray.pop()
            dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
            location = self.get_dir(dirname)
            if location and filename in location.files:
                return location.files[filename]
            return None

    def get_dir(self, path):
        path = path.rstrip(&#34;/&#34;)
        patharray = path.split(&#34;/&#34;)
        if len(patharray) &lt;= 1:
            return self.filesystem[&#34;/&#34;]
        patharray.pop(0)
        location = self.filesystem[&#34;/&#34;]
        while patharray:
            dirpath = patharray.pop(0)
            if dirpath in location.directories:
                location = location.directories[dirpath]
            else:
                return None
        return location</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>forest.fuse.LoggingMixIn</li>
<li>forest.fuse.Operations</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mem.Memory.chmod"><code class="name flex">
<span>def <span class="ident">chmod</span></span>(<span>self, path, mode)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chmod(self, path, mode):
    item = self.get_file(path)
    if not item:
        item = self.get_dir(path)
    if item:
        item.properties.st_mode &amp;= 258048
        item.properties.st_mode |= mode
    return 0</code></pre>
</details>
</dd>
<dt id="mem.Memory.chown"><code class="name flex">
<span>def <span class="ident">chown</span></span>(<span>self, path, uid, gid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chown(self, path, uid, gid):
    item = self.get_file(path)
    if not item:
        item = self.get_dir(path)
    if item:
        item.properties.st_uid = uid
        item.properties.st_gid = gid
    return 0</code></pre>
</details>
</dd>
<dt id="mem.Memory.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, path, mode)</span>
</code></dt>
<dd>
<div class="desc"><p>When raw_fi is False (default case), fi is None and create should
return a numerical file handle.</p>
<p>When raw_fi is True the file handle should be set directly by create
and return 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, path, mode):
    filename = path.split(&#34;/&#34;)[-1]
    dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
    dirobj = self.get_dir(dirname)
    now = time.time()
    dirobj.files[filename] = File(
        data=bytearray(),
        properties=Property(
            st_mode=stat.S_IFREG | mode,
            st_nlink=1,
            st_size=0,
            st_ctime=now,
            st_mtime=now,
            st_atime=now,
        ),
    )
    self.fd += 1
    return self.fd</code></pre>
</details>
</dd>
<dt id="mem.Memory.get_dir"><code class="name flex">
<span>def <span class="ident">get_dir</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dir(self, path):
    path = path.rstrip(&#34;/&#34;)
    patharray = path.split(&#34;/&#34;)
    if len(patharray) &lt;= 1:
        return self.filesystem[&#34;/&#34;]
    patharray.pop(0)
    location = self.filesystem[&#34;/&#34;]
    while patharray:
        dirpath = patharray.pop(0)
        if dirpath in location.directories:
            location = location.directories[dirpath]
        else:
            return None
    return location</code></pre>
</details>
</dd>
<dt id="mem.Memory.get_file"><code class="name flex">
<span>def <span class="ident">get_file</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file(self, path):
    if path[-1] == &#34;/&#34;:
        return None
    else:
        patharray = path.split(&#34;/&#34;)
        filename = patharray.pop()
        dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
        location = self.get_dir(dirname)
        if location and filename in location.files:
            return location.files[filename]
        return None</code></pre>
</details>
</dd>
<dt id="mem.Memory.getattr"><code class="name flex">
<span>def <span class="ident">getattr</span></span>(<span>self, path, fh=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with keys identical to the stat C structure of
stat(2).</p>
<p>st_atime, st_mtime and st_ctime should be floats.</p>
<p>NOTE: There is an incombatibility between Linux and Mac OS X
concerning st_nlink of directories. Mac OS X counts all files inside
the directory, while Linux counts only the subdirectories.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getattr(self, path, fh=None):
    st = self.get_file(path)
    if not st:
        st = self.get_dir(path)
    if not st:
        raise FuseOSError(errno.ENOENT)
    return st.properties.__dict__</code></pre>
</details>
</dd>
<dt id="mem.Memory.getxattr"><code class="name flex">
<span>def <span class="ident">getxattr</span></span>(<span>self, path, name, position=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getxattr(self, path, name, position=0):
    st = self.get_file(path)
    if not st:
        st = self.get_dir(path)
    attrs = st.properties.get(&#34;attrs&#34;, {})
    try:
        return attrs[name]
    except KeyError:
        return b&#34;&#34;</code></pre>
</details>
</dd>
<dt id="mem.Memory.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self, path) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Called on filesystem initialization. (Path is always /)</p>
<p>Use it instead of <strong>init</strong> if you start threads on initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self, path) -&gt; None:
    if self.livelock is not None:
        self.livelock.release()</code></pre>
</details>
</dd>
<dt id="mem.Memory.listxattr"><code class="name flex">
<span>def <span class="ident">listxattr</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listxattr(self, path):
    st = self.get_file(path)
    if not st:
        st = self.get_dir(path)
    attrs = st.properties.get(&#34;attrs&#34;, {})
    return list(attrs.keys())</code></pre>
</details>
</dd>
<dt id="mem.Memory.mkdir"><code class="name flex">
<span>def <span class="ident">mkdir</span></span>(<span>self, path, mode)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mkdir(self, path, mode):
    path = path.rstrip(&#34;/&#34;)
    newdir = path.split(&#34;/&#34;)[-1]
    dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
    dirobj = self.get_dir(dirname)
    now = time.time()
    dirobj.directories[newdir] = Directory(
        files={},
        directories={},
        properties=Property(
            st_mode=stat.S_IFDIR | mode,
            st_nlink=2,
            st_size=0,
            st_ctime=now,
            st_mtime=now,
            st_atime=now,
        ),
    )
    dirobj.properties.st_nlink += 1</code></pre>
</details>
</dd>
<dt id="mem.Memory.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self, path, flags)</span>
</code></dt>
<dd>
<div class="desc"><p>When raw_fi is False (default case), open should return a numerical
file handle.</p>
<p>When raw_fi is True the signature of open becomes:
open(self, path, fi)</p>
<p>and the file handle should be set directly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self, path, flags):
    logging.debug(&#34;opening&#34;, get_caller())
    self.fd += 1
    return self.fd</code></pre>
</details>
</dd>
<dt id="mem.Memory.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, path, size, offset, fh)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string containing the data requested.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, path, size, offset, fh):
    fileobj = self.get_file(path)
    return bytes(fileobj.data[offset : (offset + size)])</code></pre>
</details>
</dd>
<dt id="mem.Memory.readdir"><code class="name flex">
<span>def <span class="ident">readdir</span></span>(<span>self, path, fh)</span>
</code></dt>
<dd>
<div class="desc"><p>Can return either a list of names, or a list of (name, attrs, offset)
tuples. attrs is a dict as in getattr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readdir(self, path, fh):
    st = self.get_dir(path)
    caller_info = get_caller()
    return [&#34;.&#34;, &#34;..&#34;] + [x for x in st.files] + [x for x in st.directories]</code></pre>
</details>
</dd>
<dt id="mem.Memory.readlink"><code class="name flex">
<span>def <span class="ident">readlink</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readlink(self, path):
    st = self.get_file(path)
    return st.data</code></pre>
</details>
</dd>
<dt id="mem.Memory.removexattr"><code class="name flex">
<span>def <span class="ident">removexattr</span></span>(<span>self, path, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removexattr(self, path, name):
    st = self.get_file(path)
    if not st:
        st = self.get_dir(path)
    attrs = st.properties.get(&#34;attrs&#34;, {})
    try:
        del attrs[name]
    except KeyError:
        pass</code></pre>
</details>
</dd>
<dt id="mem.Memory.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, old, new)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(self, old, new):
    oldname = old.split(&#34;/&#34;)[-1]
    newname = new.split(&#34;/&#34;)[-1]
    parentname = &#34;/&#34;.join(old.split(&#34;/&#34;)[:-1])
    parentobj = self.get_dir(parentname)
    if self.get_file(old):
        parentobj.files[newname] = parentobj.files.pop(oldname)
    elif self.get_dir(old):
        parentobj.directories[newname] = parentobj.directories.pop(oldname)</code></pre>
</details>
</dd>
<dt id="mem.Memory.rmdir"><code class="name flex">
<span>def <span class="ident">rmdir</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmdir(self, path):
    parentname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
    parentobj = self.get_dir(parentname)
    dirname = path.split(&#34;/&#34;)[-1]
    parentobj.directories.pop(dirname)
    parentobj.properties.st_nlink -= 1</code></pre>
</details>
</dd>
<dt id="mem.Memory.setxattr"><code class="name flex">
<span>def <span class="ident">setxattr</span></span>(<span>self, path, name, value, options, position=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setxattr(self, path, name, value, options, position=0):
    st = self.get_file(path)
    if not st:
        st = self.get_dir(path)
    attrs = st.setdefault(&#34;attrs&#34;, {})
    attrs[name] = value</code></pre>
</details>
</dd>
<dt id="mem.Memory.statfs"><code class="name flex">
<span>def <span class="ident">statfs</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with keys identical to the statvfs C structure of
statvfs(3).</p>
<p>On Mac OS X f_bsize and f_frsize must be a power of 2
(minimum 512).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def statfs(self, path):
    return dict(f_bsize=BLOCK_SIZE, f_blocks=4096, f_bavail=4096)</code></pre>
</details>
</dd>
<dt id="mem.Memory.symlink"><code class="name flex">
<span>def <span class="ident">symlink</span></span>(<span>self, target, source)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a symlink <code>target -&gt; source</code> (e.g. ln -s source target)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symlink(self, target, source):
    targetname = target.split(&#34;/&#34;)[-1]
    targetdir = &#34;/&#34;.join(target.split(&#34;/&#34;)[:-1])
    targetdirobj = self.get_dir(targetdir)
    now = time.time()
    targetdirobj.files[targetname] = File(
        data=source,
        properties=Property(
            st_mode=stat.S_IFLNK,
            st_nlink=1,
            st_size=len(source),
            st_ctime=now,
            st_mtime=now,
            st_atime=now,
            st_blocks=len(source) // BLOCK_SIZE,
        ),
    )</code></pre>
</details>
</dd>
<dt id="mem.Memory.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, path, length, fh=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def truncate(self, path, length, fh=None):
    st = self.get_file(path)
    st.data = st.data[:length]
    st.properties.st_size = length
    st.properties.st_blocks = length // BLOCK_SIZE</code></pre>
</details>
</dd>
<dt id="mem.Memory.unlink"><code class="name flex">
<span>def <span class="ident">unlink</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unlink(self, path):
    dirname = &#34;/&#34;.join(path.split(&#34;/&#34;)[:-1])
    filename = path.split(&#34;/&#34;)[-1]
    st = self.get_dir(dirname)
    st.files.pop(filename)</code></pre>
</details>
</dd>
<dt id="mem.Memory.utimens"><code class="name flex">
<span>def <span class="ident">utimens</span></span>(<span>self, path, times=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Times is a (atime, mtime) tuple. If None use current time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def utimens(self, path, times=None):
    now = time.time()
    (atime, mtime) = times if times else (now, now)
    st = self.get_file(path)
    st.properties.st_atime = atime
    st.properties.st_mtime = mtime</code></pre>
</details>
</dd>
<dt id="mem.Memory.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, path, data, offset, fh)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, path, data, offset, fh):
    st = self.get_file(path)
    st.data[offset:] = data
    st.properties.st_size = len(st.data)
    st.properties.st_blocks = len(st.data) // BLOCK_SIZE
    return len(data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mem.Property"><code class="flex name class">
<span>class <span class="ident">Property</span></span>
<span>(</span><span>st_mode=493, st_nlink=0, st_size=0, st_ctime=0, st_mtime=0, st_atime=0, st_gid=0, st_uid=0, st_blocks=0)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Property(dict):
    def __init__(
        self,
        st_mode=493,
        st_nlink=0,
        st_size=0,
        st_ctime=0,
        st_mtime=0,
        st_atime=0,
        st_gid=0,
        st_uid=0,
        st_blocks=0,
    ):
        self.st_mode = st_mode
        self.st_nlink = st_nlink
        self.st_size = st_size
        self.st_ctime = st_ctime
        self.st_mtime = st_mtime
        self.st_atime = st_atime
        self.st_gid = os.getgid()
        self.st_uid = os.getuid()
        self.st_blocks = st_blocks</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mem.Directory" href="#mem.Directory">Directory</a></code></h4>
</li>
<li>
<h4><code><a title="mem.File" href="#mem.File">File</a></code></h4>
</li>
<li>
<h4><code><a title="mem.Memory" href="#mem.Memory">Memory</a></code></h4>
<ul class="two-column">
<li><code><a title="mem.Memory.chmod" href="#mem.Memory.chmod">chmod</a></code></li>
<li><code><a title="mem.Memory.chown" href="#mem.Memory.chown">chown</a></code></li>
<li><code><a title="mem.Memory.create" href="#mem.Memory.create">create</a></code></li>
<li><code><a title="mem.Memory.get_dir" href="#mem.Memory.get_dir">get_dir</a></code></li>
<li><code><a title="mem.Memory.get_file" href="#mem.Memory.get_file">get_file</a></code></li>
<li><code><a title="mem.Memory.getattr" href="#mem.Memory.getattr">getattr</a></code></li>
<li><code><a title="mem.Memory.getxattr" href="#mem.Memory.getxattr">getxattr</a></code></li>
<li><code><a title="mem.Memory.init" href="#mem.Memory.init">init</a></code></li>
<li><code><a title="mem.Memory.listxattr" href="#mem.Memory.listxattr">listxattr</a></code></li>
<li><code><a title="mem.Memory.mkdir" href="#mem.Memory.mkdir">mkdir</a></code></li>
<li><code><a title="mem.Memory.open" href="#mem.Memory.open">open</a></code></li>
<li><code><a title="mem.Memory.read" href="#mem.Memory.read">read</a></code></li>
<li><code><a title="mem.Memory.readdir" href="#mem.Memory.readdir">readdir</a></code></li>
<li><code><a title="mem.Memory.readlink" href="#mem.Memory.readlink">readlink</a></code></li>
<li><code><a title="mem.Memory.removexattr" href="#mem.Memory.removexattr">removexattr</a></code></li>
<li><code><a title="mem.Memory.rename" href="#mem.Memory.rename">rename</a></code></li>
<li><code><a title="mem.Memory.rmdir" href="#mem.Memory.rmdir">rmdir</a></code></li>
<li><code><a title="mem.Memory.setxattr" href="#mem.Memory.setxattr">setxattr</a></code></li>
<li><code><a title="mem.Memory.statfs" href="#mem.Memory.statfs">statfs</a></code></li>
<li><code><a title="mem.Memory.symlink" href="#mem.Memory.symlink">symlink</a></code></li>
<li><code><a title="mem.Memory.truncate" href="#mem.Memory.truncate">truncate</a></code></li>
<li><code><a title="mem.Memory.unlink" href="#mem.Memory.unlink">unlink</a></code></li>
<li><code><a title="mem.Memory.utimens" href="#mem.Memory.utimens">utimens</a></code></li>
<li><code><a title="mem.Memory.write" href="#mem.Memory.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mem.Property" href="#mem.Property">Property</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>