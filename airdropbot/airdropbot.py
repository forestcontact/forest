#!/usr/bi:n/python3.9
# pylint: disable=too-many-branches disable=too-many-return-statements disable=line-too-long
# pylint: disable=too-many-arguments disable=too-many-nested-blocks
# pylint: disable=too-many-lines disable=unused-argument
"""Executable file which starts up a bot which does mobilecoin airdrops"""
import logging
import json
import asyncio
from datetime import datetime
from enum import Enum
from typing import Any, Union, Optional
from dataclasses import dataclass, field
from asyncio import create_task
from aiohttp import web
import mc_util
from forest.core import PayBot, app, Message, Response, requires_admin, hide
from forest.utils import get_secret
from forest.pghelp import Loop, PGExpressions, PGInterface

FEE_MOB = 0.0004
FEE_PMOB = 400000000
SIGNAL_PAY = 'go to Signal Settings > Payments > Activate Payments > Accept and Agree to Terms to activate signal payments!'

AirdropPGExpressions = PGExpressions(
    table="aidrops",
    create_table="CREATE TABLE airdrops ( \
            id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, \
            drop_id text UNIQUE NOT NULL, \
            created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL, \
            updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL, \
            drop_type text NOT NULL, start_block integer NOT NULL, data jsonb );",
    initialize_defaults="INSERT INTO airdrops (drop_id, start_block, drop_type, data \
            VALUES ('no_airdrop', 0, 'none', '{{\\\"tx_list\\\":[]}}') ON \
            CONFLICT DO NOTHING;",
    create_simple_airdrop="INSERT INTO airdrops (drop_id, start_block, drop_type, data) \
            VALUES ($1, $2, $3, '{{\\\"tx_list\\\":[]}}');",
    sd_add_tx="UPDATE airdrops SET data = jsonb_set(data,'{{\\\"tx_list\\\", \
            99999999}}', $2, TRUE) WHERE drop_id = $1 ;",
    sd_get_unpaid_entrants="SELECT username, wallet_address, tx_block, bot_number \
            FROM airdrops,jsonb_to_recordset(airdrops.data->'tx_list')  AS (username text, \
            wallet_address text, tx_block integer, tx_purpose text, bot_number text) \
            WHERE drop_id = $1 and tx_purpose = 'airdrop_entry' AND username NOT IN \
            (SELECT username from airdrops, \
            jsonb_to_recordset(airdrops.data->'tx_list') as (username text, tx_purpose \
            text) WHERE drop_id=$1 AND tx_purpose='airdrop_payout');",
    sd_get_paid_entrants="SELECT username, wallet_address, tx_block, bot_number\
            FROM airdrops,jsonb_to_recordset(airdrops.data->'tx_list') \
            AS (username text, wallet_address text, tx_block integer, tx_purpose text, bot_number text) \
            WHERE drop_id = $1 AND tx_purpose = 'airdrop_payout'",
    sd_get_all_transactions="SELECT username, wallet_address, amount direction, \
            tx_purpose, tx_block, bot_number \
            FROM airdrops,jsonb_to_recordset(airdrops.data->'tx_list') \
            AS (username text, wallet_address text, amount numeric, direction \
            text, tx_purpose text, tx_block integer, bot_number text) \
            WHERE drop_id = $1 and tx_block > start_block;",
)


class AirdropManager(PGInterface):
    "Airdrop database ORM"

    def __init__(
        self,
        queries: PGExpressions = AirdropPGExpressions,
        database: str = get_secret("DATABASE_URL"),
        loop: Loop = None,
    ) -> None:
        super().__init__(queries, database, loop)


def try_cast_float(value: Any) -> Union[float, Any]:
    """
    Attempt to cast to float
    """
    if isinstance(value, bool):
        logging.warning(
            "bool value passed, aborting typecast to avoid undesired casting errors"
        )
        return value
    try:
        fvalue = float(value)
        return fvalue
    except Exception:  # pylint: disable=broad-except
        return value


def try_cast_int(value: Any) -> Union[int, Any]:
    """
    Attempt to cast to int
    """
    if isinstance(value, (float, bool)):
        logging.warning(
            "float or bool value passed, aborting typecast to avoid undesired casting errors"
        )
        return value
    try:
        ivalue = int(value)
        return ivalue
    except Exception:  # pylint: disable=broad-except
        return value


class States(Enum):
    """
    Possible environment states. States are not mutually exclusive
    """

    SETUP = 1
    NEEDS_FUNDING = 2
    READY_TO_LAUNCH = 3
    LIVE = 4
    AIRDROP_FULL = 5
    AIRDROP_FINISHED = 6
    NO_AIRDROP = 7
    ERROR = 8


class Dialog(Enum):
    """
    Possible dialogs
    """

    NONE = 1
    ADMIN_AIRDROP_SETUP = 2
    ADMIN_DISTRIBUTE_MOBILECOIN = 3


@dataclass
class Airdrop:
    """
    Base aidrop configuration type
    """
    name: str = "no_airdrop"
    # pylint: disable=R0201
    def is_configured_correctly(self) -> bool:
        """
        Is the airdrop configured correctly, alwayas false for base aidrop type
        """
        return False


@dataclass
class SimpleAirdrop(Airdrop):  # pylint: disable=too-many-instance-attributes
    """
    Configuration meant to represent an airdrop that distributes an equal
    amount to each participant
    """

    name: str = "no_airdrop"
    entry_price: float = -1.0
    drop_amount: float = -1.0
    max_entrants: int = -1
    start_block: int = -1
    dialog: Dialog = Dialog.NONE
    setup_script: dict[str, str] = field(default_factory=dict)
    drop_script: dict[str, str] = field(default_factory=dict)
    dialog_state: dict = field(default_factory=dict)

    def __post_init__(self) -> None:
        logging.info("Instantiating airdrop configuration, type: simple")
        self.setup_script = dict(
            welcome="Welcome to aidrop setup, I will now ask series of questions to setup "
            "your drop\nYou may exit this at anytime by typing another /command "
            "or by typing 'exit' at anytime",
            entry_price=("What's the entry price for this airdrop? The amount "
            "entered here will be pre-dropped to users, which they will "
            "then pay back immediately to enter the airdrop. \n\nEnter an "
            "integer or decimal number representing the amount of MoB "
            "users will need to pay to enter"),
            entry_price_invalid="Entry price must be a positive number, please re-enter",
            drop_amount="How many MoB will be given out to each entrant when the airdrop starts? (enter integer or decimal)",
            drop_amount_invalid="Drop amount must be a positive number, please re-enter",
            max_entrants="How many entrants total are allowed? (enter integer)",
            max_entrants_invalid="Max entrants must be a positive whole number, please re-enter",
            setup_finished="Airdrop setup complete! Type /launch_airdrop to begin the airdrop",
            exit="Exiting setup. You may return to this dialog anytime by typing /setup_airdrop",
        )
        self.drop_script = dict(
            welcome="You've initiated a drop. Drop options:\n",
            options=(
                "{num_users} unpaid users fully registred for airdrop\n"
                "1. Distribute {drop_amount} MoB to all current entrants.\n"
                "2. Drop {drop_amount} MoB to specified amount of entrants"
            ),
            options_invalid="Input invalid, enter 1 or 2 to choose an option",
            specify_amount="Enter # of entrants to make drop to, {num_users} unpaid airdrop enterants remaining",  # pylint: disable=line-too-long
            specify_amount_invalid="Input invalid, enter a whole number",
            confirm_airdrop="Type 'confirm' to drop {amt} mob to {num_users} users",
            confirm_airdrop_invalid="Invalid input, type confirm to make drop or exit to cancel",
            confirmed="Attemping to airdrop {amt} mob to {num_users} entrants",
            exit="Cancelling mob distribution, you can re-enter this dialog using /make_drop",
        )
        self.dialog_state = {}

    def is_configured_correctly(self) -> bool:
        """
        Checks for valid values for Simple Airdrop config type

        Returns:
          bool: whether setup for airdrop is complete
        """
        return self.entry_price > 0 and self.drop_amount > 0 and self.max_entrants > 0

    def end_dialog(self) -> None:
        """
        Clear all dialog artifacts
        """
        self.dialog_state = {}
        logging.info("Exiting dialog %s", self.dialog.name)
        self.dialog = Dialog.NONE

    def enter_dialog(self, dialog: Dialog) -> None:
        """
        Enter new dialog, clear old dialog artifacts

        args:
          dialog (Dialog): dialog: type of dialog to enter
        """
        self.dialog_state = {}
        if not dialog in Dialog:
            logging.warning("Invalid dialog specified, no dialog started")
            return
        logging.info("Entering dialog %s", dialog.name)
        self.dialog = dialog

    def set_airdrop(self, block: int, name: str) -> None:
        """
        Set block airdrop will start at. Once this is set, bot will consider
        airdrop launched.

        args:
          block (int): Block to start airdrop at
          name (str): Name of the airdrop
        """
        if self.start_block >= 0:
            logging.info("Airdrop in process, please clear airdrop before proceeding")
            return
        logging.info("setting Airdrop start at block %s", block)
        self.start_block = block
        self.name = name

    def clear_airdrop(self) -> None:
        """
        Clear airdrop configuration, this ends the airdrop
        """
        logging.info("Resetting airdrop to default values")
        self.name = "simple_airdrop_setup"
        self.dialog = Dialog.NONE
        self.dialog_state = {}
        self.set_airdrop(-1, "no_airdrop")
        self.max_entrants = -1
        self.entry_price = -1.0
        self.drop_amount = -1.0

    def get_next_dialog(  # pylint: disable=too-many-branches disable=too-many-return-statements
        self, invalid: bool = False, data: Optional[dict] = None
    ) -> str:
        """
        Gets next dialog in setup sequence based on current configuration

        args:
          invalid (bool): return dialog that responds to invalid input
          data (Optional[dict]): associated metadata needed for dialog

        Returns:
          str: next setup dialog
        """
        valid = ""
        if invalid:
            valid = "_invalid"

        if self.dialog == Dialog.ADMIN_AIRDROP_SETUP:
            if self.entry_price < 0:
                return (
                    self.setup_script["welcome"]
                    + "\n\n"
                    + self.setup_script["entry_price" + valid]
                )
            if self.drop_amount < 0:
                return self.setup_script["drop_amount" + valid]
            if self.max_entrants < 1:
                return self.setup_script["max_entrants" + valid]
            self.end_dialog()
            return self.setup_script["setup_finished"]

        if (
            self.dialog == Dialog.ADMIN_DISTRIBUTE_MOBILECOIN
        ):  # pylint: disable=too-many-nested-blocks
            if isinstance(data, dict):
                unpaid_entrants = data.get("num_unpaid_entrants")
                selection = self.dialog_state.get("selection")
                num_to_drop = self.dialog_state.get("num_to_drop")
                confirmed = self.dialog_state.get("confirmed")
                if not selection and not confirmed:
                    return self.drop_script["options" + valid].format(
                        num_users=unpaid_entrants, drop_amount=self.drop_amount
                    )
                if selection:
                    if selection == 1:
                        if confirmed:
                            return self.drop_script["confirmed"].format(
                                num_users=unpaid_entrants, amt=self.drop_amount
                            )
                        return self.drop_script["confirm_airdrop" + valid].format(
                            num_users=unpaid_entrants, amt=self.drop_amount
                        )
                    if selection == 2:
                        if num_to_drop:
                            if confirmed:
                                return self.drop_script["confirmed"].format(
                                    num_users=num_to_drop, amt=self.drop_amount
                                )
                            return self.drop_script["confirm_airdrop" + valid].format(
                                num_users=num_to_drop, amt=self.drop_amount
                            )
        self.end_dialog()
        return ""

    def take_next_input(
        self, value: Any, data: dict
    ) -> str:  # pylint: disable=too-many-return-statements
        """
        Take input via a dialog flow

        args:
          value (Any): Value input during dialog flow

        Returns:
          str: reply string
        """
        if self.dialog == Dialog.ADMIN_AIRDROP_SETUP:
            logging.info("airdrop state is %s", repr(self))
            if value == "exit":
                self.end_dialog()
                return self.setup_script.get("exit", "Exiting dialog")
            if self.entry_price < 0:
                value = try_cast_float(value)
                if isinstance(value, (float, int)) and (value > 0):
                    self.entry_price = value
                    return self.get_next_dialog()
                return self.get_next_dialog(invalid=True)
            if self.drop_amount < 0:
                value = try_cast_float(value)
                if isinstance(value, (float, int)) and (value > 0):
                    self.drop_amount = value
                    return self.get_next_dialog()
                return self.get_next_dialog(invalid=True)
            if self.max_entrants < 1:
                value = try_cast_int(value)
                if isinstance(value, (int)) and (value > 0):
                    self.max_entrants = value
                    return self.get_next_dialog()
                return self.get_next_dialog(invalid=True)
            return self.get_next_dialog()

        if self.dialog == Dialog.ADMIN_DISTRIBUTE_MOBILECOIN:
            unpaid_entrants = data.get("num_unpaid_entrants")
            selection = self.dialog_state.get("selection")
            num_to_drop = self.dialog_state.get("num_to_drop")
            confirmed = self.dialog_state.get("confirmed")
            if value == "exit":
                self.end_dialog()
                return self.drop_script.get("exit", "Exiting dialog")
            if not selection:
                value = try_cast_int(value)
                if isinstance(value, int) and (
                    -1 < value < 2
                ):  # pylint: disable=chained-comparison
                    self.dialog_state["selection"] = value
                    if value == 1:
                        self.dialog_state["num_to_drop"] = unpaid_entrants
                    return self.get_next_dialog(data=data)
                return self.get_next_dialog(invalid=True, data=data)
            if selection:
                if selection == 2:
                    num_to_drop = self.dialog_state.get("num_to_drop")
                    if not num_to_drop:
                        num_to_drop = try_cast_int(value)
                        if (
                            isinstance(num_to_drop, int)
                            and isinstance(unpaid_entrants, int)
                            and unpaid_entrants >= num_to_drop
                        ):
                            self.dialog_state["num_to_drop"] = num_to_drop
                            return self.get_next_dialog(data=data)
                        return self.get_next_dialog(invalid=True, data=data)
                    if (
                        isinstance(num_to_drop, int)
                        and isinstance(unpaid_entrants, int)
                        and unpaid_entrants >= num_to_drop
                    ):
                        if value == "confirm":
                            self.dialog_state["confirmed"] = True
                            logging.info(
                                "Airdrop of %s to %s entrants confirmed",
                                self.drop_amount,
                                num_to_drop,
                            )
                            return self.get_next_dialog(data=data)
                        return self.get_next_dialog(invalid=True, data=data)
                if selection == 1:
                    if confirmed:
                        return self.get_next_dialog(data=data)
                    if value == "confirm":
                        self.dialog_state["confirmed"] = True
                        logging.info(
                            "Airdrop of %s to %s entrants confirmed",
                            self.drop_amount,
                            unpaid_entrants,
                        )
                        return self.get_next_dialog(data=data)
                    return self.get_next_dialog(invalid=True, data=data)

        self.end_dialog()
        return ""

    def get_total_airdrop_amount(self, include_fees: bool = True, padding: float = 0.05) -> float:
        """
        Calculate total aidrop pot

        args:
          include_fees (bool): return amount plus estimated fees
          padding (float): fraction of total pot that should be available to
          cover unexpected events

        Returns
          float: total mob to distribute in airdrop
        """
        total_drop = self.max_entrants * self.drop_amount
        if include_fees:

            return (
                total_drop
                + self.max_entrants
                * ( FEE_MOB * 3)
                + total_drop*padding
            )
        return total_drop

    def is_ready_to_launch(self, balance: Union[float, int]) -> bool:
        """
        Check balance to determine if airdrop is ready to start

        args:
          balance (Union[float, int]): wallet balance in pmob

        Returns:
          bool: whether airdrop can start
        """

        cost = self.get_total_airdrop_amount(include_fees=True)
        enough_mob_available = balance > cost
        configured_correctly = self.is_configured_correctly()
        can_start = enough_mob_available and configured_correctly
        if not enough_mob_available:
            logging.warning(
                "Airdrop will cost %s but wallet only has %s", cost, balance
            )
        if not configured_correctly:
            logging.warning("Airdrop is not configured correctly")
        return can_start

    @staticmethod
    def to_pmob(amount: Union[float, int]) -> int:
        """
        Takes amount in mob, returns amount in pmob
        """

        return int(mc_util.mob2pmob(amount))

    @staticmethod
    def to_mob(amount: int) -> float:
        """
        Takes amount in pmob, returns amount in mob
        """

        return float(round(mc_util.pmob2mob(amount), 4))

    def __repr__(self) -> str:
        resp = (
            "\nAidrop Configuration:\n"
            f"Airdrop Name: {self.name}\n"
            f"Start Block: {self.start_block}\n"
            f"Drop Amount: {self.drop_amount}\n"
            f"Max Entrants: {self.max_entrants}\n"
            f"Entry Price: {self.entry_price}\n"
            f"Dialog State: {self.dialog}"
        )
        if self.is_configured_correctly():
            total = self.get_total_airdrop_amount()
            resp += f"\nDrop Total + Fees: {total}"
        return resp


InteractiveAirdrop = Union[SimpleAirdrop]


class AirDropBot(PayBot):
    """
    Bot which takes airdrop entrants and provides a drop!
    """

    def __init__(self) -> None:
        self.name = "MobDripper"
        self.config: Airdrop = Airdrop()
        self.entrant_list: dict = {}
        self.db_manager = AirdropManager()
        super().__init__()

    @staticmethod
    def is_admin(msg: Message) -> bool:
        """
        Determine if message sender is admin
        """
        admin = get_secret("ADMIN")
        return msg.source == admin

    async def handle_message(self, message: Message) -> Response:
        if self.is_admin(message) and isinstance(self.config, SimpleAirdrop):
            if not (message.text or message.command) or message.group:
                return None
            if self.config.dialog == Dialog.ADMIN_AIRDROP_SETUP:
                logging.info("In Aidrop Setup")
                if message.command:
                    self.config.end_dialog()
                    return await super().handle_message(message)
                return self.config.take_next_input(message.text, {})
            if self.config.dialog == Dialog.ADMIN_DISTRIBUTE_MOBILECOIN:
                unpaid_entrants = self.get_entrants()
                data = {"num_unpaid_entrants": len(unpaid_entrants)}
                dialog = self.config.take_next_input(message.text, data)
                if self.config.dialog_state.get("confirmed") is True:
                    num_to_drop = self.config.dialog_state.get("num_to_drop", 0)
                    create_task(self.distribute_drop(num_to_drop))
                    self.config.end_dialog()
                return dialog
        if message.payment:
            return await self.process_payment(message)

        return await super().handle_message(message)

    async def process_payment(self, message: Message) -> Response:
        """
        Handle refunding of payments to users legitimately entering airdrop or
        sending unsolicted payments
        """
        conf = self.config
        assert isinstance(conf, InteractiveAirdrop)
        state = await self.get_state()
        refund_without_fees = "we are refunding your payment minus transaction fees!"
        refund_with_fees = "we are refunding your payment and transaction fees!"
        if not States.LIVE in state:
            create_task(self.return_payment(message, "not_live"))
            return f"No airdrop in progress, {refund_without_fees}"
        if States.AIRDROP_FULL in state and not self.entrant_list.get(message.source):
            create_task(self.return_payment(message, "aidrop_full"))
            return f"This airdrop has reached the maximum amount of entrants, {refund_without_fees}"
        if message.source in self.entrant_list and isinstance(
            self.config, SimpleAirdrop
        ):
            status = self.entrant_list.get(message.source,{}).get("status")
            if status == "prepaid":
                create_task(self.return_payment(message, "prepaid_airdrop_entry"))
                return "You've successfully entered the airdrop!"
            if status == "unpaid":
                create_task(self.return_payment(message, "duplicate_payment"))
                return f"You've already entered this airdrop, {refund_without_fees}"
        if isinstance(self.config, SimpleAirdrop) and not (
            message.source in self.entrant_list
        ):
            if message.text and "pay me" in message.text.lower():
                if self.entrant_list.get(message.source) or not States.LIVE in state:
                    return None
                wallet_address = await self.get_address(message.source)
                if not wallet_address:
                    return ("You haven't yet enabled Signal Pay! To "
                            f"enable it {SIGNAL_PAY}\n\nAfter "
                            "you've done that, I'll send you the initial "
                            f"{conf.entry_price} MoB!"
                            )
                create_task(self.return_payment(message, "prepay"))
                return (
                        f"Okay! I'm sending you {conf.entry_price + FEE_MOB} "
                        f"MoB, send me back {conf.entry_price} MoB to enter the "
                        f"airdrop. Once entered, you will be dropped "
                        f"{conf.drop_amount} MoB once the airdrop starts!"
                        )
            create_task(self.return_payment(message, "airdrop_entry"))
            return f"You've successfully entered the airdrop! Since you sent your own MoB {refund_with_fees}"
        create_task(self.return_payment(message, "Unexpected"))
        return f"Your payment was unexpected, {refund_without_fees}"

    async def return_payment(
        self, msg: Message, reason: str, fee: int = 400000000
    ) -> None:
        """
        Return payments sent to the bot to the original sender

        args:
          msg (Response): Message object sent to the bot
          reason (str): Reason payment is being sent back
        """
        conf = self.config
        wallet_address = await self.get_address(msg.source)
        assert isinstance(conf, InteractiveAirdrop)
        assert isinstance(wallet_address, str)
        entry_block = await self.mobster.get_current_network_block()
        amount_to_send = 0
        amount_received = 0
        payment_message = "Your payment has been refunded!"
        if reason == "prepay":
            amount_to_send =  conf.to_pmob(conf.entry_price) + fee
            payment_message = f"I've sent you {conf.to_mob(amount_to_send)} MoB"
            self.entrant_list[msg.source] = dict(
                    status="prepaid",
                    wallet_address=wallet_address,
                    number=msg.source,
                    entry_block=entry_block
                    )

        if msg.payment:
            logging.info("attempting to confirm payment from %s", msg.source)
            amount_received = await self.mobster.get_receipt_amount_pmob(msg.payment["receipt"]) # type: ignore
            assert isinstance(amount_received, int)
            amount_to_send = amount_received - fee
            create_task(
                self.record_tx(
                    msg.source,
                    reason,
                    amount_received,
                    "tx_direction_received",
                    wallet_address,
                    entry_block,
                )
            )

        if reason in ["airdrop_entry", "prepaid_airdrop_entry"]:
            if reason == "airdrop_entry":
                amount_to_send = amount_received + fee
            logging.info("%s entered airdrop, adding to list", msg.source)
            self.entrant_list[msg.source] = dict(
                entry_fee=amount_received,
                status="unpaid",
                number=msg.source,
                wallet_address=wallet_address,
                entry_block=entry_block,
            )
            num_entrants = len(self.get_entrants("paid"))
            if isinstance(conf, InteractiveAirdrop) and num_entrants >= conf.max_entrants:
                full_msg = f"Airdrop is full with {num_entrants}/{conf.max_entrants} entrants, please make drop by typing /make_drop"
                create_task(self.send_message(get_secret("ADMIN"), full_msg))


        if amount_to_send < 0 or reason == "prepaid_airdrop_entry":
            return

        logging.info(
            "refunding %s MoB paid to %s reason: %s",
            float(mc_util.pmob2mob(amount_to_send)),
            msg.source,
            reason,
        )

        result = await self.send_payment(
            msg.source, amount_to_send, payment_message, 30, comment=reason
        )
        logging.info("Return payment result was %s", result)
        create_task(
            self.record_tx(
                msg.source,
                reason,
                amount_to_send,
                "tx_direction_sent",
                wallet_address,
                entry_block,
            )
        )

    async def default(self, message: Message) -> Response:
        conf = self.config
        state = await self.get_state()
        resp = f"You've messaged {self.name}. \n\n"
        logging.info("default reply to %s - state %s", message.source, state)
        if message.text and not (message.group or message.source == self.bot_number):
            if States.AIRDROP_FINISHED in state:
                if self.is_admin(message):
                    return "Hi admin, the aidrop is paid out in full, type /finish_airdrop to clean it up!"
                if message.source in self.get_entrants("paid", num_only=True):
                    return "Your MoB has been delivered! I appreciate you so much for participating, come back soon! "
                return "Hello there, the airdrop recently in progress has finished! Please check back later"
            if not isinstance(conf, InteractiveAirdrop) or (States.SETUP in state):
                if self.is_admin(message):
                    if not isinstance(conf, InteractiveAirdrop):
                        resp = ("Hi admin, no aidrop is currently configured. Type "
                        "/setup_airdrop to configure one\n")
                        resp += "\nOther commands:\n" + self.documented_commands()
                        return resp
                    if not conf.is_configured_correctly():
                        resp = ("Hi admin, an airdrop configuration is in progress. "
                        "Further configuration is needed, type /setup_airdrop "
                        "to enter airdrop setup\n")
                    else:
                        resp = "Hi admin, airdrop configuration is complete\n"
                    if States.NEEDS_FUNDING in state:
                        resp += ("\nThe airdrop wallet does not have enough funds "
                        f"please add at least {conf.get_total_airdrop_amount()} "
                        "to the wallet before launching the airdrop\n")
                    if States.READY_TO_LAUNCH in state:
                        resp = ("Hi admin, airdrop configuration is complete and "
                        "fully funded, you can launch it by typing /launch_airdrop\n")
                    resp += "\nYou can check airdrop configuration using /drop_stats\n"
                    resp += "\nOther commands:\n" + self.documented_commands()
                    return resp
                resp += "Hello! No airdrop is in progress please check back later"
                return resp

            if States.LIVE in state or States.AIRDROP_FINISHED in state:
                if self.is_admin(message):
                    resp = "Hello admin, an airdop is in progress.\n"
                    if States.NEEDS_FUNDING in state:
                        resp += "but has insufficient funding, PLEASE FUND IMMEDIATELY!"
                        return resp
                    if States.AIRDROP_FULL in state:
                        resp += "Airdrop is full!\n"
                    resp += "Make the drop to current entrants by typing /make_drop\n"
                    resp += "Get airdrop stats with /drop_stats\n"
                    resp += "Cancel the drop with /cancel_drop\n"
                    return resp

                resp += "Hello! An aidrop is in progress. "
                if message.source in self.entrant_list:
                    status = self.entrant_list.get(message.source, {}).get("status")
                    if status == "unpaid":
                        resp += "You've already entered the Airdrop! You'll receive your MoB soon. "
                    if status == "prepaid":
                        resp += (f"I've sent you {conf.entry_price + FEE_MOB} MoB! Please "
                        f"send {conf.entry_price} back and you will be entered "
                        "into the airdrop!")
                    if status == "paid":
                        resp = "Your MoB has been delivered! I appreciate you so much for participating, come back soon! "
                if not self.entrant_list.get(message.source):
                    if States.AIRDROP_FULL in state:
                        resp += "unfortunately the airdrop is full. Please check back later!"
                        return resp
                    if "pay me" in message.text.lower() and not States.AIRDROP_FINISHED in state:
                        return await self.process_payment(message)

                    resp += (
                        f"{self.name} is currently dropping {conf.drop_amount} to "
                        f"each entrant for the first {conf.max_entrants} "
                        "entrants.\n\nTo enter this airdrop:\n1. Enable signal pay if "
                        "you have not already\n2. Message me 'pay me' and I "
                        f"will send you {conf.entry_price + FEE_MOB} MoB\n"
                        f"3. Send me {conf.entry_price} MoB and you will be "
                        "entered into the airdrop!\n4. When the airdrop starts "
                        f"you'll be sent {conf.drop_amount} MOB! \n\n"
                        f"P.S. If you haven't enabled Signal Pay {SIGNAL_PAY}"
                    )
                return resp
        return None

    async def record_tx(
        self,
        sender: str,
        reason: str,
        amount: int,
        direction: str,
        wallet_address: str,
        entry_block: int,
    ) -> None:
        """
        Record transaction into database to be recovered in case of bot failure
        """

        state = await self.get_state()
        if States.LIVE in state and isinstance(self.config, SimpleAirdrop):
            data = dict(
                username=sender,
                wallet_address=wallet_address,
                amount=amount,
                direction=direction,
                tx_purpose=reason,
                tx_block=entry_block,
                bot_number=self.bot_number,
            )

            logging.info("logging %s - %s:%s:%s", direction, sender, amount, reason)
            await self.db_manager.sd_add_tx(self.config.name, json.dumps(data))

    async def get_state(self) -> set[States]:
        """
        get airdrop state based on environment

        Returns:
          set: Set of state
        """
        states = set()
        conf = self.config
        num_entrants = len(self.entrant_list)
        paid_entrants = self.get_entrants("paid")
        num_paid_entrants = len(paid_entrants)
        if isinstance(conf, SimpleAirdrop):
            if conf.max_entrants > 0:
                if num_paid_entrants >= num_entrants >= conf.max_entrants:
                    states.add(States.AIRDROP_FINISHED)
                    return states
            if not conf.is_configured_correctly():
                states.add(States.SETUP)
            else:
                wallet_balance = await self.mobster.get_wallet_balance()
                if conf.is_ready_to_launch(wallet_balance):
                    if conf.start_block > 0:
                        states.add(States.LIVE)
                    else:
                        if num_entrants > 0:
                            states.add(States.ERROR)
                            return states
                        states.add(States.SETUP)
                        states.add(States.READY_TO_LAUNCH)
                else:
                    if num_entrants > 0 or conf.start_block > 0:
                        states.add(States.LIVE)
                        states.add(States.NEEDS_FUNDING)
                        states.add(States.ERROR)
                        logging.critical(
                            "Airdrop is live without funding, please fund wallet immediately!!"
                        )
                    else:
                        states.add(States.SETUP)
                        states.add(States.NEEDS_FUNDING)
                if num_entrants >= conf.max_entrants:
                    states.add(States.AIRDROP_FULL)
        else:
            states.add(States.NO_AIRDROP)
        logging.debug("state are %s", states)
        return states

    async def distribute_drop(self, num_to_drop: int, max_retries: int = 2) -> None:
        """
        Executes payment of airdrop amount to recipients
        """
        config = self.config
        assert isinstance(config, SimpleAirdrop)
        account_id = await self.mobster.get_account()
        logging.debug("pre allocating transactions for %s users", num_to_drop)
        pool = await self.mobster.preallocate_txos(account_id,[config.to_pmob(config.drop_amount)]*(num_to_drop + 1))
        await asyncio.sleep(10)
        unpaid = self.get_entrants()
        if num_to_drop > len(unpaid):
            msg = "Number of requested drops above number of users entered, aborting"
            await self.send_message(get_secret("ADMIN"), msg)
            return
        drop_amount = int(mc_util.mob2pmob(config.drop_amount))
        unpaid = unpaid[0:num_to_drop]
        network_block = await self.mobster.get_current_network_block()
        for entrant in unpaid:
            entrant_address = await self.get_address(entrant["number"])
            logging.info("Attempting to pay %s",entrant.get("number"))
            logging.info("Entrant profile: %s", entrant)
            if not isinstance(entrant_address, str):
                logging.warning("could not payment address for %s, skipping", entrant.get("number"))
                continue
            await asyncio.sleep(4)  # avoid rate limit
            utxo = pool.pop(-1)
            utxo_hash = utxo[0]
            payment_message = (
                    "Here's your airdrop! I've just sent you "
                    f"{float(mc_util.pmob2mob(drop_amount))} MoB! Thank you so much "
                    "for participating!")
            result = await self.send_payment(
                entrant["number"],
                drop_amount,
                payment_message,
                30,
                comment="airdrop_payout",
                input_txo_ids=[utxo_hash]
            )
            logging.info("payment result is %s", result)
            
            assert isinstance(entrant_address, str)
            create_task(self.record_tx(get_secret("ADMIN"), "airdrop_payout",
                drop_amount, "tx_direction_sent", entrant_address,
                network_block))
            self.entrant_list[entrant["number"]]["status"] = "paid"
        drop_stats = await self.get_drop_stats()
        await self.send_message(get_secret("ADMIN"), drop_stats)

    async def reconcile_data(self, start_block: int) -> dict[str, list]:
        """
        Returns any discrepancies that exist in the airdrop bot's payment
        records and full service payment records. If "mismatch_paid" records
        exist, it indicates that the bot has recorded payments which weren't
        actually made. "Mismatch_unpaid" indicates some entrants haven't been
        tracked by the bot.

        args:
          start_block (int): Block from which to measure discrepancies

        Returns:
          dict(str, set): List of mismatches in paid and unpaid entrants
        """
        config = self.config
        assert isinstance(config, SimpleAirdrop)
        paid = set(entrant["wallet_address"] for entrant in self.get_entrants("paid"))
        unpaid = set(
            entrant["wallet_address"] for entrant in self.get_entrants("unpaid")
        )
        fs_entrants = await self.get_entrants_from_full_service(start_block)
        fs_paid = set(fs_entrants["paid_entrants"])
        fs_unpaid = set(fs_entrants["unpaid_entrants"])
        paid_diff = list(paid - fs_paid)
        unpaid_diff = list(unpaid - fs_unpaid)
        return {"mismatch_paid": paid_diff, "mismatch_unpaid": unpaid_diff}

    async def get_entrants_from_full_service(self, start_block: int) -> dict[str, list]:
        """
        Get full service record of which entrants have been entered and/or have
        been paid.

        args:
          start_block (int): block from which to measure from

        Returns:
          dict[str, list]: list of paid and unpaid entrants within the block
          specified
        """
        account_id = await self.mobster.get_account()
        record_list = await self.mobster.get_transactions(account_id)
        _id = "recipient_address_id"
        entrants: set = set()
        paid_entrants: set = set()
        for _, record in record_list.items():
            sent_block = try_cast_int(record.get("finalized_block_index"))
            otxos = record.get("output_txos")
            if (
                isinstance(sent_block, int)
                and sent_block >= start_block
                and record.get("direction") == "tx_direction_sent"
                and isinstance(otxos, list)
            ):
                for txo in otxos:
                    if record.get("comment") in ["prepaid_airdrop_entry","airdrop_entry"] and txo.get(_id):
                        entrants.add(txo.get(_id))
                    if record.get("comment") == "airdrop_payout" and txo.get(_id):
                        paid_entrants.add(txo.get(_id))
        unpaid_entrants: set = entrants - paid_entrants
        return {
            "entrants": list(entrants),
            "paid_entrants": list(paid_entrants),
            "unpaid_entrants": list(unpaid_entrants),
        }

    def get_entrants(self, status: str = "unpaid", num_only:bool=False) -> list:
        """
        Get entrants based on paid or unpaid status

        args:
          status (str): either "paid" to get entrants who have been sent mob or
          "unpaid" to get entrants who have yet to receive an airdrop
        """
        entrants = self.entrant_list
        if num_only:
            return [k for k, v in entrants.items() if v["status"] == status]
        return [v for _, v in entrants.items() if v["status"] == status]

    @hide
    @requires_admin
    async def do_make_drop(self, msg: Message) -> Response:
        """
        Initiate Airdrop
        """
        state = await self.get_state()
        if States.SETUP in state:
            return "Airdrop currently in setup, please finish setup"
        if States.ERROR in state:
            return "Airdrop is in error state, please correct error before continuing"
        if States.NO_AIRDROP in state:
            return (
                "No Airdrop active, please configure and launch one before continuing"
            )
        if States.LIVE in state and isinstance(self.config, SimpleAirdrop):
            if States.NEEDS_FUNDING in state:
                amount_needed = self.config.get_total_airdrop_amount()
                resp = f"Funding needed, ensure wallet has at least {amount_needed} MoB"
                logging.warning(resp)
                return resp
            unpaid_entrants = self.get_entrants()
            if len(unpaid_entrants) <= 0:
                return "No airdrop entrants yet, please wait until there are entrants"
            data = {"num_unpaid_entrants": len(unpaid_entrants)}
            self.config.enter_dialog(Dialog.ADMIN_DISTRIBUTE_MOBILECOIN)
            return self.config.get_next_dialog(data=data)
        if States.AIRDROP_FINISHED:
            return "Airdrop finished, cannot make further drops, please type /finish_airdrop to cleanup airdrop"
        return "Not able to make drop"

    @hide
    @requires_admin
    async def do_drop_stats(
        self, msg: Message
    ) -> Response:  # pylint: disable=unused-argument
        """
        Get stats on airdrop
        """
        return await self.get_drop_stats()

    async def get_drop_stats(self) -> Response:
        """
        Provide data on airdrop status
        """
        state = await self.get_state()
        if States.NO_AIRDROP in state:
            return "Sorry, no aidrop in progress"
        conf = self.config
        num_entrants = len(self.entrant_list)
        num_prepaid = len(self.get_entrants("prepaid"))
        num_paid = len(self.get_entrants("paid"))
        num_entered = len(self.get_entrants("unpaid"))
        wallet_balance = await self.mobster.get_wallet_balance()
        assert isinstance(conf, InteractiveAirdrop)
        if wallet_balance >= 0:
            finances = f"Wallet Balance: {wallet_balance}"
        else:
            finances = "Wallet Balance: Error getting balance!"
        resp = f"{finances}\n" + f"{repr(conf)}"
        if States.LIVE in state:
            prefix = (f"Airdrop live\n # of entrants: {num_entrants}\n"
                    f"# of entrants given starter MoB: {num_prepaid}\n"
                    f"# of entrants fully entered: {num_entered}\n"
                    f"# of entrants paid in full: {num_paid}\n")
            if States.NEEDS_FUNDING in state:
                prefix += "CRITICAL: AIRDROP HAS ENTRANTS BUT LACKS FUNDING, FUND IMMEDIATELY\n"
            if States.AIRDROP_FULL in state:
                prefix += "AIRDROP FULL!\n"
            return prefix + resp
        if States.AIRDROP_FINISHED in state:
            prefix = ("Airdrop Finished! "
            f"{num_entrants}/{len(self.get_entrants('paid'))} entrants paid "
            f"{conf.drop_amount} MoB. Type /finish_airdrop to cleanup drop\n")
            return prefix + resp
        if States.SETUP in state:
            setup_done = conf.is_configured_correctly()
            prefix = (
                "Setup is currently in progress\n"
                f"Setup Complete: {setup_done}\n"
                f"Fully Funded: {not (States.NEEDS_FUNDING in state)}\n"
                f"Able to Launch: {States.READY_TO_LAUNCH in state}\n"
            )
            return prefix + resp

        return "Drop in Error State\n" + f"# of entrants {num_entrants}\n" + resp

    @hide
    @requires_admin
    async def do_launch_airdrop(
        self, msg: Message
    ) -> Response:  # pylint: disable=unused-argument
        """
        Put airdrop in state to accept funds from users
        """
        resp = "No airdop configured, cannot launch"
        conf = self.config
        state = await self.get_state()
        if States.LIVE in state:
            return "Airdrop already in progress, cannot launch new aidrop"

        if isinstance(conf, InteractiveAirdrop) and States.SETUP in state:
            if States.READY_TO_LAUNCH in state:
                block_height = await self.mobster.get_current_network_block()
                if block_height < 0:
                    return "Network block height couldn't be found, aborting launch"
                time = datetime.utcnow().strftime("%Y_%m_%d_%H")
                name = f"simple_airdrop_{block_height}_{time}"
                conf.set_airdrop(block_height, name)
                await self.db_manager.create_simple_airdrop(
                    name, block_height, "simple"
                )
                return f"Airdrop launched at block: {block_height}, {self.name} will now accept payments. Airdrop UUID is: {name}"
            if States.NEEDS_FUNDING in state:
                funds = await self.mobster.get_wallet_balance()
                deficit = conf.get_total_airdrop_amount() - funds
                return f"Airdrop needs funding, please fund with {deficit} MoB"
            return "Airdop setup not complete, type /setup_airdop to finish setup"

        if States.ERROR in state:
            resp = "Aidrop is in an error state, please fix before launching"

        return resp

    @hide
    @requires_admin
    async def do_setup_airdrop(
        self, msg: Message
    ) -> str:  # pylint: disable=unused-argument
        """
        Setup new airdrop or re-enter in progress airdrop
        """
        state = await self.get_state()
        if States.NO_AIRDROP in state:
            self.config = SimpleAirdrop()
            assert isinstance(self.config, SimpleAirdrop)
            self.config.enter_dialog(Dialog.ADMIN_AIRDROP_SETUP)
            return self.config.get_next_dialog()
        if States.LIVE in state:
            return "An airdrop is in progress, cannot setup a new one"
        if States.ERROR in state:
            return "Airdrop is in error state, cannot enter setup"
        if States.SETUP in state:
            assert isinstance(self.config, InteractiveAirdrop)
            self.config.enter_dialog(Dialog.ADMIN_AIRDROP_SETUP)
            return self.config.get_next_dialog()
        return "Unknown Error, cannot setup airdrop"

    @hide
    @requires_admin
    async def do_cancel_airdrop(self, msg: Message) -> Response:
        """
        Cancel airdrop and reset airdrop data
        """
        state = await self.get_state()
        resp = "Airdrop being cancelled, you can restart one at anytime"
        if States.AIRDROP_FINISHED in state:
            resp = "Airdrop should be finished with /finish_airdrop command"
        if States.LIVE in state:
            if self.get_entrants("unpaid"):
                return "Entrants exist who have not been paid, please make a drop before cancelling"
            resp = "Cancelling drop"
        if States.SETUP in state:
            resp = "Airdrop configuration cancelled, you can configure another at anytime"
        self.config = Airdrop()
        self.entrant_list = {}
        return resp

    @hide
    @requires_admin
    async def do_finish_airdrop(self, msg: Message) -> Response:
        """
        Cleanup Airdrop
        """
        state = await self.get_state()
        if States.AIRDROP_FINISHED in state:
            self.config = Airdrop()
            self.entrant_list = {}
            return "All airdrop data cleared, you may start another at anytime"
        if States.LIVE in state:
            return "There are still unpaid entrants in the list, please payout remaining entrants before finishing airdrop"
        if States.SETUP in state:
            return "Airdrop is still in setup, can't finish something that's not been started silly!"
        return "No airdrop is currently in progress"


if __name__ == "__main__":

    @app.on_startup.append
    async def start_wrapper(out_app: web.Application) -> None:
        """
        Start App
        """

        out_app["bot"] = AirDropBot()

    web.run_app(app, port=8080, host="0.0.0.0", access_log=None)
