#!/usr/bi:n/python3.9
"""Executable file which starts up a bot which does mobilecoin airdrops"""
import logging
from enum import Enum
from typing import Any, Union, Optional
from dataclasses import dataclass, field
from asyncio import create_task
from aiohttp import web
from datetime import datetime
from forest.core import PayBot, app, Message, Response, requires_admin, hide
from forest.utils import get_secret
from forest.pghelp import Loop, PGExpressions, PGInterface

AirdropPGExpressions = PGExpressions(
    table="aidrops",
    create_table="CREATE TABLE airdrops ( \
            id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, \
            drop_id text UNIQUE NOT NULL, \
            created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL, \
            updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL, \
            drop_type text NOT NULL, start_block integer NOT NULL, data jsonb );",
    create_simple_airdrop="INSERT INTO airdrops (drop_id, start_block, drop_type, data) \
            VALUES ($1, $2, $3, '{{\\\"tx_list\\\":[]}}');",
    sd_add_tx="UPDATE airdrops SET data = jsonb_set(data,'{{\\\"tx_list\\\", \
            9999999}}', $2, TRUE) WHERE drop_id = $1 ;",
    sd_get_unpaid_entrants="SELECT username, wallet_address, tx_block, bot_number \
            FROM airdrops,jsonb_to_recordset(airdrops.data->'tx_list')  AS (username text, \
            wallet_address text, tx_block integer, tx_purpose text, bot_number text) \
            WHERE drop_id = $1 and tx_purpose = 'airdrop_entry' AND username NOT IN \
            (SELECT username from airdrops, \
            jsonb_to_recordset(airdrops.data->'tx_list') as (username text, tx_purpose \
            text) WHERE drop_id=$1 AND tx_purpose='airdrop_payout');",
    sd_get_paid_entrants="SELECT username, wallet_address, tx_block, bot_number\
            FROM airdrops,jsonb_to_recordset(airdrops.data->'tx_list') \
            AS (username text, wallet_address text, tx_block integer, tx_purpose text, bot_number text) \
            WHERE drop_id = $1 AND tx_purpose = 'airdrop_payout'",
    sd_get_all_transactions="SELECT username, wallet_address, amount direction, tx_purpose, tx_block, bot_number \
            FROM airdrops,jsonb_to_recordset(airdrops.data->'tx_list') \
            AS (username text, wallet_address text, amount numeric, direction text, tx_purpose text, tx_block integer, bot_number text) \
            WHERE drop_id = $1 and tx_block > start_block;",
)

class AirdropManager(PGInterface):
    def __init__(
        self,
        queries: PGExpressions = AirdropPGExpressions,
        database: str = get_secret("DATABASE_URL"),
        loop: Loop = None
    ) -> None:
        super().__init__(queries, database, loop)



def try_cast_float(value: Any) -> Union[float, Any]:
    """
    Attempt to cast to float
    """
    if isinstance(value, bool):
        logging.warning(
            "bool value passed, aborting typecast to avoid undesired casting errors"
        )
        return value
    try:
        fvalue = float(value)
        return fvalue
    except Exception:  # pylint: disable=broad-except
        return value


def try_cast_int(value: Any) -> Union[int, Any]:
    """
    Attempt to cast to int
    """
    if isinstance(value, (float, bool)):
        logging.warning(
            "float or bool value passed, aborting typecast to avoid undesired casting errors"
        )
        return value
    try:
        ivalue = int(value)
        return ivalue
    except Exception:  # pylint: disable=broad-except
        return value


class States(Enum):
    """
    Possible environment states. States are not mutually exclusive
    """

    SETUP = 1
    NEEDS_FUNDING = 2
    READY_TO_LAUNCH = 3
    LIVE = 4
    AIRDROP_FULL = 5
    AIRDROP_FINISHED = 6
    NO_AIRDROP = 7
    ERROR = 8


class Dialog(Enum):
    """
    Possible dialogs
    """

    NONE = 1
    ADMIN_AIRDROP_SETUP = 2
    ADMIN_DISTRIBUTE_MOBILECOIN = 3


@dataclass
class Airdrop:
    """
    Base aidrop configuration type
    """

    # pylint: disable=R0201
    def is_configured_correctly(self) -> bool:
        """
        Is the airdrop configured correctly, alwayas false for base aidrop type
        """
        return False


@dataclass
class SimpleAirdrop(Airdrop):  # pylint: disable=too-many-instance-attributes
    """
    Configuration meant to represent an airdrop that distributes an equal
    amount to each participant
    """
    name: str = "simple_airdrop_setup"
    entry_price: float = -1.0
    drop_amount: float = -1.0
    max_entrants: int = -1
    start_block: int = -1
    dialog: Dialog = Dialog.NONE
    setup_script: dict[str, str] = field(default_factory=dict)
    drop_script: dict[str, str] = field(default_factory=dict)
    dialog_graph: dict = field(default_factory=dict)

    def __post_init__(self) -> None:
        logging.info("Instantiating airdrop configuration, type: simple")
        self.setup_script = dict(
            welcome="Welcome to aidrop setup, I will now ask series of questions to setup"
            "your drop \n You may exit this at anytime by typing another /command"
            "or by typing 'exit' at anytime",
            entry_price="What is the entry price for this airdrop (enter integer or decimal)",
            entry_price_invalid="Entry price must be a positive number, please re-enter",
            drop_amount="How many mob will be given out to each entrant (enter integer or decimal)",
            drop_amount_invalid="Drop amount must be a positive number, please re-enter",
            max_entrants="How many entrants total are allowed? (enter integer or decimal)",
            max_entrants_invalid="Max entrants must be a positive whole number, please re-enter",
            setup_finished="Airdrop setup complete! Type /launch_aidrop to begin the airdrop",
            exit="Exiting setup. You may return to this dialog anytime by typing /setup_airdrop",
        )
        self.drop_script = dict(
            welcome="You've initiated a drop. Drop options:\n",
            options=(
                "1. Distribute {self.drop_amount} MoB to all current entrants.\n"
                "2. Drop {self.drop_amount} to specified amount of entrants"
            ),
            options_invalid="Please type a number to choose an option",
            specify_amount="Please type how many entrants to make drop to",
            specify_amount_invalid="Input invalid, please enter a whole number",
            confirm_airdrop="Drop configure, type 'confirm' to make drop ",
            confirmation="Attemping to make an airdrop",
            exit="Cancelling mob distribution, you can re-enter this dialog at anytime using /make_drop",
        )

    def is_configured_correctly(self) -> bool:
        """
        Checks for valid values for Simple Airdrop config type

        Returns:
          bool: whether setup for airdrop is complete
        """
        return self.entry_price > 0 and self.drop_amount > 0 and self.max_entrants > 1

    def get_next_dialog(self, invalid: bool = False, data: Optional[dict] = None) -> str:
        """
        Gets next dialog in setup sequence based on current configuration

        Returns:
          str: next setup dialog
        """
        valid = ""
        if invalid:
            valid = "_invalid"

        if self.dialog == Dialog.ADMIN_AIRDROP_SETUP:
            if self.entry_price < 0:
                return self.setup_script["entry_price" + valid]
            if self.drop_amount < 0:
                return self.setup_script["drop_amount" + valid]
            if self.max_entrants < 1:
                return self.setup_script["max_entrants" + valid]
            self.dialog = Dialog.NONE
            return self.setup_script["setup_finished"]

        if self.dialog == Dialog.ADMIN_DISTRIBUTE_MOBILECOIN:
            if isinstance(data, dict):
                paid_entrants = data.get("num_paid_entrants")
                unpaid_entrants = data.get("num_unpaid_entrants")
                selection = self.dialog_graph.get("selection")


    def take_next_input(
        self, value: Any, data: dict
    ) -> str:  # pylint: disable=too-many-return-statements
        """
        Take input via a dialog flow

        args:
          value (Any): Value input during dialog flow

        Returns:
          str: reply string
        """
        if self.dialog == Dialog.ADMIN_AIRDROP_SETUP:
            if value == "exit":
                self.dialog = Dialog.NONE
                return self.setup_script.get("exit", "Exiting dialog")
            if self.entry_price < 0:
                value = try_cast_float(value)
                if isinstance(value, (float, int)) and (value > 0):
                    self.entry_price = value
                    return self.get_next_dialog()
                return self.get_next_dialog(invalid=True)
            if self.drop_amount < 0:
                value = try_cast_float(value)
                if isinstance(value, (float, int)) and (value > 0):
                    self.drop_amount = value
                    return self.get_next_dialog()
                return self.get_next_dialog(invalid=True)
            if self.max_entrants < 1:
                value = try_cast_int(value)
                if isinstance(value, (int)) and (value > 0):
                    self.max_entrants = value
                    return self.get_next_dialog()
                return self.get_next_dialog(invalid=True)
            return self.get_next_dialog()

        if dialog == Dialog.ADMIN_DISTRIBUTE_MOBILECOIN:
            num_entrants = data.get("num_entrants", -1)
            num_paid = data.get("num_paid", -1)

    def get_total_airdrop_amount(self, include_fees: bool = True) -> float:
        """
        Calculate total aidrop pot

        args:
          include_fees (bool): return amount plus estimated fees

        Returns
          float: total mob to distribute in airdrop
        """
        total_drop = self.max_entrants * self.drop_amount
        if include_fees:
            return (
                total_drop
                + self.max_entrants * 0.01
                + self.entry_price * self.max_entrants
            )
        return total_drop

    def is_ready_to_launch(self, balance: Union[float, int]) -> bool:
        """
        Check balance to determine if airdrop is ready to start

        args:
          balance (Union[float, int]): wallet balance in pmob

        Returns:
          bool: whether airdrop can start
        """

        cost = self.get_total_airdrop_amount(include_fees=True)
        enough_mob_available = balance < cost
        configured_correctly = self.is_configured_correctly()
        can_start = enough_mob_available and configured_correctly
        if not enough_mob_available:
            logging.warning(
                "Airdrop will cost %s but wallet only has %s", cost, balance
            )
        if not configured_correctly:
            logging.warning("Airdrop is not configured correctly")
        if can_start:
            logging.info(
                "Airdrop configured correctly with sufficient balance, airdrop can start"
            )
        return can_start

    def __repr__(self) -> str:
        resp = (
            "\nAidrop Configuration:\n"
            f"Start Block: {self.start_block}\n"
            f"Drop Amount: {self.drop_amount}\n"
            f"Max Entrants: {self.max_entrants}\n"
            f"Entry Price: {self.entry_price}"
        )
        if self.is_configured_correctly():
            total = self.get_total_airdrop_amount()
            resp += f"\nDrop Total + Fees: {total}"
        return resp


InteractiveAirdrop = Union[SimpleAirdrop]


class AirDropBot(PayBot):
    """
    Bot which takes airdrop entrants and provides a drop!
    """

    def __init__(self) -> None:
        self.name = "MobDripper"
        self.config: Airdrop = Airdrop()
        self.entrant_list: dict = {}
        self.airdrop_finished = False
        self.db_manager = AirdropManager()
        super().__init__()

    @staticmethod
    def is_admin(msg: Message) -> bool:
        """
        Determine if message sender is admin
        """
        admin = get_secret("ADMIN")
        return msg.source == admin

    async def record_tx(self, sender: str, reason: str,
            amount: int, direction: str) -> None:
        state = await self.get_state()
        if States.LIVE in state:
            block = await self.mobster.get_current_network_block()
            wallet_address = await self.get_address(sender)
            data=dict(
                    username=sender,
                    wallet_address=wallet_address,
                    amount=amount,
                    direction=direction,
                    tx_purpose=reason,
                    tx_block=block,
                    bot_number=self.bot_number
                    )
            data = json.dumps(data)
            logging.info("logging {direction} - {sender}:{amount}:{reason}")
            await self.db_manager.sd_add_tx(self.config_name, data)                

    async def get_state(self) -> set[States]:
        """
        get airdrop state based on environment
        """
        states = set()
        conf = self.config
        num_entrants = len(self.entrant_list)
        if isinstance(conf, SimpleAirdrop):
            if self.airdrop_finished:
                states.add(States.AIRDROP_FINISHED)
                return states
            if not conf.is_configured_correctly():
                states.add(States.SETUP)
            else:
                wallet_balance = await self.mobster.get_wallet_balance()
                if conf.is_ready_to_launch(wallet_balance):
                    if conf.start_block > 0:
                        states.add(States.LIVE)
                    else:
                        if num_entrants > 0:
                            states.add(States.ERROR)
                            return states
                        states.add(States.SETUP)
                        states.add(States.READY_TO_LAUNCH)
                else:
                    if num_entrants > 0 or conf.start_block > 0:
                        states.add(States.LIVE)
                        states.add(States.NEEDS_FUNDING)
                        states.add(States.ERROR)
                        logging.critical(
                            "Airdrop is live without funding, please fund wallet immediately!!"
                        )
                    else:
                        states.add(States.SETUP)
                        states.add(States.NEEDS_FUNDING)
                if num_entrants > conf.max_entrants:
                    states.add(States.AIRDROP_FULL)
        else:
            states.add(States.NO_AIRDROP)
        return states

    async def handle_message(self, message: Message) -> Response:
        if self.is_admin(message) and isinstance(self.config, SimpleAirdrop):
            if self.config.dialog == Dialog.ADMIN_AIRDROP_SETUP:
                if message.command:
                    self.config.dialog = (
                        Dialog.NONE
                    )  # pylint: disable=attribute-defined-outside-init
                    return await super().handle_message(message)
                return self.config.take_next_input(message.text, {})
        if message.payment:
            return await self.process_payment(message)
        return await super().handle_message(message)

    async def process_payment(self, message: Message) -> Response:
        """
        Handle refunding of payments to users legitimately entering airdrop or
        sending unsolicted payments
        """
        state = await self.get_state()
        refund_without_fees = "we are refunding your payment minus transaction fees!"
        refund_with_fees = "We are refunding your payment and transaction fees!"
        if not States.LIVE in state:
            create_task(self.return_payment(message, state, "not_live"))
            return f"No airdrop in progress, {refund_without_fees}"
        if States.AIRDROP_FULL in state:
            create_task(self.return_payment(message, state, "aidrop_full"))
            return f"This airdrop has reached the maximum amount of entrants, {refund_without_fees}"
        if message.source in self.entrant_list and isinstance(
            self.config, SimpleAirdrop
        ):
            create_task(self.return_payment(message, state, "duplicate_payment"))
            return f"You've already entered this airdrop, {refund_without_fees}"
        if isinstance(self.config, SimpleAirdrop) and not (
            message.source in self.entrant_list
        ):
            create_task(self.return_payment(message, state, "airdrop_entry"))
            return f"You've successfully entered the airdrop! {refund_with_fees}"
        create_task(self.return_payment(message, state, "Unexpected"))
        return f"Your payment was unexpected, {refund_without_fees}"

    async def return_payment(
            self, msg: Message, state: set[States], reason: str, fee: int = 400000000
        ) -> None:
        """
        Return payments sent to the bot to the original sender

        args:
          msg (Response): Message object sent to the bot
          reason (str): Reason payment is being sent back
        """
        
        assert msg.payment
        logging.info(msg.payment)
        amount_pmob = await self.mobster.get_receipt_amount_pmob(msg.payment["receipt"])
        if isinstance(amount_pmob, int):
            create_task(self.record_tx(msg.source, reason, amount_pmob,
            "tx_direction_received"))
            amount = amount_pmob + fee
            if reason != "Airdrop Entry":
                amount = amount_pmob - fee
            await self.send_payment(
                msg.source, amount, "Your payment has been refunded!", reason
            )
            create_task(self.record_tx(msg.source, reason, amount_pmob,
            "tx_direction_sent"))

    async def get_entrants_from_full_service(self, start_block: int) -> dict[str, list]:
        account_id = await self.mobster.get_account()
        record_list = await self.mobster.get_transactions(account_id)
        _id = "recipient_address_id"
        entrants: set = set()
        paid_entrants: set = set()
        for _, record in record_list.items():
            sent_block = try_cast_int(record.get("finalized_block_index"))
            otxos = record.get("output_txos")
            if (
                isinstance(sent_block, int)
                and sent_block >= start_block
                and record.get("direction") == "tx_direction_sent"
                and isinstance(otxos, list)
            ):
                for txo in otxos:
                    if record.get("comment") == "airdrop_entry" and txo.get(_id):
                        entrants.add(txo.get(_id))
                    if record.get("comment") == "airdrop_payout" and txo.get(_id):
                        paid_entrants.add(txo.get(_id))
        unpaid_entrants: set = entrants - paid_entrants
        return {
            "entrants": list(entrants),
            "paid_entrants": list(paid_entrants),
            "unpaid_entrants": list(unpaid_entrants),
        }

    async def do_make_drop(self, msg: Message) -> Response:
        """
        Initiate Airdrop
        """
        pass

    async def default(self, message: Message) -> Response:
        conf = self.config
        state = await self.get_state()
        resp = f"You've messaged {self.name}. \n\n"
        if message.txt and not (message.group or message.txt == resp):
            if not isinstance(conf, InteractiveAirdrop) or (States.SETUP in state):
                if self.is_admin(message):
                    resp = "Hi admin, no aidrop is currently configured\n"
                    if States.SETUP in state:
                        resp = "Hi admin, an airdrop configuration is in progress\n"
                    resp += "type /setup_airdrop to enter airdrop setup\n"
                    resp += "\nOther commands:\n" + self.documented_commands()
                    return resp
                resp += "No aidrop is in progress, please check back later"
                return resp

            if States.LIVE in state:
                if self.is_admin(message):
                    resp = "Hello admin, an airdop is in progress\n"
                    if States.NEEDS_FUNDING in state:
                        resp += "but has insufficient funding, PLEASE FUND IMMEDIATELY!"
                        return resp
                    if States.AIRDROP_FULL in state:
                        resp += "Airdrop is full!\n"
                    resp += "Make the drop to current entrants by typing /make_drop\n"
                    resp += "Get airdrop stats with /drop_stats\n"
                    resp += "Cancel the drop with /cancel_drop\n"
                    resp += "\nOther commands:\n" + self.documented_commands()
                    return resp

                resp += "Hello! An aidrop is in progress, "
                if message.source in self.entrant_list:
                    resp += "you've already entered the Airdrop! You'll receive your MoB soon."
                else:
                    resp += (
                        f"{self.name} is currently dropping {conf.drop_amount} to "
                        f"each entrant for the first {conf.max_entrants} "
                        f"entrants. To enter please send {conf.entry_price} "
                        "MOB to this bot with signal pay. You'll be sent "
                        f"back {conf.entry_price} + network fees immediately. "
                        "When the airdrop starts you'll be sent "
                        f"{conf.drop_amount} MOB!"
                    )
                return resp
        return None

    @hide
    @requires_admin
    async def do_drop_stats(
        self, msg: Message
    ) -> Response:  # pylint: disable=unused-argument
        """
        Get stats on airdrop
        """
        state = await self.get_state()
        if States.NO_AIRDROP in state:
            return "Sorry, no aidrop in progress"
        conf = self.config
        num_entrants = len(self.entrant_list)
        wallet_balance = await self.mobster.get_wallet_balance()
        assert isinstance(conf, InteractiveAirdrop)
        if wallet_balance >= 0:
            finances = f"Wallet Balance: {wallet_balance}"
        else:
            finances = "Wallet Balance: Error getting balance!"
        resp = f"{finances}\n" + f"{repr(conf)}"
        if States.LIVE in state:
            prefix = "Airdrop live\n" + f"# of entrants: {num_entrants}\n"
            if States.NEEDS_FUNDING in state:
                prefix += "CRITICAL: AIRDROP HAS ENTRANTS BUT LACKS FUNDING, FUND IMMEDIATELY\n"
            if States.AIRDROP_FULL in state:
                prefix += "AIRDROP FULL!\n"
            return prefix + resp
        if States.SETUP in state:
            setup_done = conf.is_configured_correctly()
            prefix = (
                "Setup is currently in progress\n"
                f"Setup Complete: {setup_done}\n"
                f"Fully Funded: {States.NEEDS_FUNDING in state}\n"
                f"Able to Launch: {States.READY_TO_LAUNCH in state}\n"
            )
            return prefix + resp
        return "Drop in Error State\n" + f"# of entrants {num_entrants}\n" + resp

    @hide
    @requires_admin
    async def do_launch_airdrop(
        self, msg: Message
    ) -> Response:  # pylint: disable=unused-argument
        """
        Put airdrop in state to accept funds from users
        """
        resp = "No airdop configured, cannot launch"
        conf = self.config
        state = await self.get_state()
        if States.LIVE in state:
            return "Airdrop already in progress, cannot launch new aidrop"

        if isinstance(conf, InteractiveAirdrop) and States.SETUP in state:
            if States.READY_TO_LAUNCH in state:
                block_height = await self.mobster.get_current_network_block()
                if block_height < 0:
                    return "Network block height couldn't be found, aborting launch"
                conf.start_block = (
                    block_height  # pylint: disable=attribute-defined-outside-init
                    )
                time = datetime.utcnow().strftime("%Y_%m_%d_%H")
                name = f"simple_airdrop_{block_height}_{time}"
                self.db_manager.create_simple_airdrop(name, block_height,"simple")
                return f"Airdrop launched, {self.name} will now accept payments"
            if States.NEEDS_FUNDING in state:
                funds = await self.mobster.get_wallet_balance()
                deficit = conf.get_total_airdrop_amount() - funds
                return f"Airdrop needs funding, please fund with {deficit} MoB"
            return "Airdop setup not complete, type /setup_airdop to finish setup"

        if States.ERROR in state:
            resp = "Aidrop is in an error state, please fix before launching"

        return resp

    @hide
    @requires_admin
    async def do_setup_airdrop(
        self, msg: Message
    ) -> str:  # pylint: disable=unused-argument
        """
        Setup new airdrop or re-enter in progress airdrop
        """
        state = await self.get_state()
        if States.NO_AIRDROP in state:
            self.config = SimpleAirdrop()
            assert isinstance(self.config, SimpleAirdrop)
            resp = self.config.setup_script.get("welcome", "Welcome to airdrop setup")
            resp += "\n" + self.config.get_next_dialog()
            self.config.dialog = (
                Dialog.ADMIN_AIRDROP_SETUP
            )
            return resp
        if States.LIVE in state:
            return "An airdrop is in progress, cannot setup a new one"
        if States.ERROR in state:
            return "Airdrop is in error state, cannot enter setup"
        if States.SETUP in state:
            assert isinstance(self.config, InteractiveAirdrop)
            self.config.dialog = (
                Dialog.ADMIN_AIRDROP_SETUP # pylint: disable=attribute-defined-outside-init
            )
            return self.config.get_next_dialog()
        return "Unknown Error, cannot setup airdrop"


if __name__ == "__main__":

    @app.on_startup.append
    async def start_wrapper(out_app: web.Application) -> None:
        """
        Start App
        """

        out_app["bot"] = AirDropBot()

    web.run_app(app, port=8080, host="0.0.0.0", access_log=None)
