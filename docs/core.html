<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>core API documentation</title>
<meta name="description" content="The core chatbot framework: Message, Signal, Bot, and app" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>core</code></h1>
</header>
<section id="section-intro">
<p>The core chatbot framework: Message, Signal, Bot, and app</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python3.9
&#34;&#34;&#34;
The core chatbot framework: Message, Signal, Bot, and app
&#34;&#34;&#34;
import asyncio
import asyncio.subprocess as subprocess  # https://github.com/PyCQA/pylint/issues/1469
import json
import logging
import os
import signal
import sys
from asyncio import Queue, StreamReader, StreamWriter
from asyncio.subprocess import PIPE
from typing import Any, AsyncIterator, Optional, Union

import aiohttp
import phonenumbers as pn
import termcolor
from aiohttp import web
from phonenumbers import NumberParseException

# framework
from forest import datastore
from forest import pghelp
from forest import utils
from forest import mc_util
from forest import payments_monitor

JSON = dict[str, Any]
Response = Union[str, list, dict[str, str], None]


class Message:
    &#34;&#34;&#34;Represents a Message received from signal-cli, optionally
    containing a command with arguments, group, quote, or payment&#34;&#34;&#34;

    def __init__(self, blob: dict) -&gt; None:
        self.blob = blob
        self.envelope = envelope = blob.get(&#34;envelope&#34;, {})
        # {&#39;envelope&#39;: {&#39;source&#39;: &#39;+15133278483&#39;, &#39;sourceDevice&#39;: 2, &#39;timestamp&#39;: 1621402445257, &#39;receiptMessage&#39;: {&#39;when&#39;: 1621402445257, &#39;isDelivery&#39;: True, &#39;isRead&#39;: False, &#39;timestamps&#39;: [1621402444517]}}}

        # envelope data
        self.source: str = envelope.get(&#34;source&#34;)
        self.name: str = envelope.get(&#34;sourceName&#34;) or self.source
        self.timestamp = envelope.get(&#34;timestamp&#34;)

        # msg data
        msg = envelope.get(&#34;dataMessage&#34;, {})
        self.full_text = self.text = msg.get(&#34;message&#34;, &#34;&#34;)
        self.group: Optional[str] = msg.get(&#34;groupInfo&#34;, {}).get(&#34;groupId&#34;)
        self.quoted_text = msg.get(&#34;quote&#34;, {}).get(&#34;text&#34;)
        self.payment = msg.get(&#34;payment&#34;)

        # parsing
        self.command: Optional[str] = None
        self.tokens: Optional[list[str]] = None
        if self.text and self.text.startswith(&#34;/&#34;):
            command, *self.tokens = self.text.split(&#34; &#34;)
            self.command = command[1:].lower()  # remove /
            self.arg1 = self.tokens[0] if self.tokens else None
            self.text = &#34; &#34;.join(self.tokens)
        # self.reactions: dict[str, str] = {}

    def __repr__(self) -&gt; str:
        # it might be nice to prune this so the logs are easier to read
        return f&#34;&lt;{self.envelope}&gt;&#34;


class Signal:
    &#34;&#34;&#34;
    Represents a signal-cli session.
    Lifecycle: Downloads the datastore, runs and restarts signal-cli,
    tries to gracefully kill signal-cli and upload before exiting.
    I/O: reads signal-cli&#39;s output into signalcli_output_queue,
    has methods for sending commands to signal-cli, and
    actually writes those json blobs to signal-cli&#39;s stdin.
    &#34;&#34;&#34;

    def __init__(self, bot_number: Optional[str] = None) -&gt; None:
        if not bot_number:
            try:
                bot_number = utils.signal_format(sys.argv[1])
                assert bot_number is not None
            except IndexError:
                bot_number = utils.get_secret(&#34;BOT_NUMBER&#34;)
        logging.debug(&#34;bot number: %s&#34;, bot_number)
        self.bot_number = bot_number
        self.datastore = datastore.SignalDatastore(bot_number)
        self.proc: Optional[subprocess.Process] = None
        self.signalcli_output_queue: Queue[Message] = Queue()
        self.signalcli_input_queue: Queue[dict] = Queue()
        self.exiting = False

    async def start_process(self) -&gt; None:
        &#34;&#34;&#34;
        Add SIGINT handlers. Download datastore. Maybe set profile.
        (Re)start signal-cli and launch reading and writing with it.
        &#34;&#34;&#34;
        # things that don&#39;t work: loop.add_signal_handler(async_shutdown) - TypeError
        # signal.signal(sync_signal_handler) - can&#39;t interact with loop
        loop = asyncio.get_running_loop()
        loop.add_signal_handler(signal.SIGINT, self.sync_signal_handler)
        logging.debug(&#34;added signal handler, downloading...&#34;)
        if not utils.get_secret(&#34;NO_DOWNLOAD&#34;):
            await self.datastore.download()
        if utils.get_secret(&#34;PROFILE&#34;):
            await self.set_profile()
        while self.sigints == 0 and not self.exiting:
            command = f&#34;{utils.ROOT_DIR}/signal-cli --config {utils.ROOT_DIR} --output=json stdio&#34;.split()
            logging.info(command)
            self.proc = await asyncio.create_subprocess_exec(
                *command, stdin=PIPE, stdout=PIPE
            )
            logging.info(
                &#34;started signal-cli @ %s with PID %s&#34;,
                self.bot_number,
                self.proc.pid,
            )
            assert self.proc.stdout and self.proc.stdin
            asyncio.create_task(self.handle_signalcli_raw_output(self.proc.stdout))
            asyncio.create_task(self.write_commands(self.proc.stdin))
            returncode = await self.proc.wait()
            logging.warning(&#34;signal-cli exited: %s&#34;, returncode)
            if returncode == 0:
                logging.info(&#34;signal-cli apparently exited cleanly, not restarting&#34;)
                break

    sigints = 0

    def sync_signal_handler(self, *_: Any) -&gt; None:
        &#34;&#34;&#34;Try to start async_shutdown and/or just sys.exit&#34;&#34;&#34;
        logging.info(&#34;handling sigint. sigints: %s&#34;, self.sigints)
        self.sigints += 1
        self.exiting = True
        try:
            loop = asyncio.get_running_loop()
            logging.info(&#34;got running loop, scheduling async_shutdown&#34;)
            asyncio.run_coroutine_threadsafe(self.async_shutdown(), loop)
        except RuntimeError:
            asyncio.run(self.async_shutdown())
        if self.sigints &gt;= 3:
            sys.exit(1)

    async def async_shutdown(self, *_: Any, wait: bool = False) -&gt; None:
        &#34;&#34;&#34;Upload our datastore, close postgres connections pools, kill signal-cli, exit&#34;&#34;&#34;
        logging.info(&#34;starting async_shutdown&#34;)
        await self.datastore.upload()
        if self.proc:
            try:
                self.proc.kill()
                if wait:
                    await self.proc.wait()
                    await self.datastore.upload()
            except ProcessLookupError:
                logging.info(&#34;no signal-cli process&#34;)
        await self.datastore.mark_freed()
        await pghelp.close_pools()
        # this still deadlocks. see https://github.com/forestcontact/forest-draft/issues/10
        if datastore._memfs_process:
            executor = datastore._memfs_process._get_executor()
            logging.info(executor)
            executor.shutdown(wait=False, cancel_futures=True)
        logging.info(&#34;exited&#34;.center(60, &#34;=&#34;))
        sys.exit(0)
        logging.info(&#34;called sys.exit but still running, trying os._exit&#34;)
        os._exit(1)

    async def handle_signalcli_raw_output(self, stream: StreamReader) -&gt; None:
        &#34;&#34;&#34;Read signal-cli output but delegate handling it&#34;&#34;&#34;
        while True:
            line = (await stream.readline()).decode().strip()
            if not line:
                break
            await self.handle_signalcli_raw_line(line)
        logging.info(&#34;stopped reading signal-cli stdout&#34;)

    async def handle_signalcli_raw_line(self, line: str) -&gt; None:
        &#34;&#34;&#34;Try to parse a single line of signal-cli output. If it&#39;s a message, enqueue it&#34;&#34;&#34;
        # TODO: maybe output and color non-json. pretty-print errors
        # unrelatedly, try to sensibly color the other logging stuff like http logs
        # fly / db / asyncio and other lib warnings / java / signal logic and networking
        try:
            blob = json.loads(line)
        except json.JSONDecodeError:
            logging.info(&#34;signal: %s&#34;, line)
            return
        if not isinstance(blob, dict):  # e.g. a timestamp
            return
        if &#34;error&#34; in blob:
            if &#34;traceback&#34; in blob:
                exception, *tb = blob[&#34;traceback&#34;].split(&#34;\n&#34;)
                logging.error(termcolor.colored(exception, &#34;red&#34;))
                # maybe also send this to admin as a signal message
                for _line in tb:
                    logging.error(_line)
            else:
                logging.error(termcolor.colored(blob[&#34;error&#34;], &#34;red&#34;))
            return
        msg = Message(blob)
        if msg.full_text:  # and utils.get_secret(&#34;I_AM_NOT_A_FEDERAL_AGENT&#34;):
            logging.info(&#34;signal: %s&#34;, line)
        await self.signalcli_output_queue.put(msg)
        return

    # i&#39;m tempted to refactor these into handle_messages
    async def signalcli_output_iter(self) -&gt; AsyncIterator[Message]:
        &#34;&#34;&#34;Provides an asynchronous iterator over messages on the queue.
        See Bot for how messages and consumed and dispatched&#34;&#34;&#34;
        while True:
            message = await self.signalcli_output_queue.get()
            yield message

    # Next, we see how the input queue is populated and consumed.

    async def set_profile(self) -&gt; None:
        &#34;&#34;&#34;Set signal profile. Note that this will overwrite any mobilecoin address&#34;&#34;&#34;
        env = utils.get_secret(&#34;ENV&#34;)
        profile = {
            &#34;command&#34;: &#34;updateProfile&#34;,
            &#34;given-name&#34;: &#34;localbot&#34; if utils.LOCAL else &#34;forestbot&#34;,
            &#34;family-name&#34;: &#34;&#34; if env == &#34;prod&#34; else env,  # maybe not?
            &#34;avatar&#34;: &#34;avatar.png&#34;,
        }
        await self.signalcli_input_queue.put(profile)
        logging.info(profile)

    async def send_message(  # pylint: disable=too-many-arguments
        self,
        recipient: Optional[str],
        msg: Response,
        group: Optional[str] = None,  # maybe combine this with recipient?
        endsession: bool = False,
        attachments: Optional[list[str]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Builds send command with specified recipient and msg, writes to signal-cli.
        Prettyprints dict msgs, sends multiple messages for lists. Also does groups,
        attachments, and endsession&#34;&#34;&#34;
        if isinstance(msg, list):
            for m in msg:
                await self.send_message(recipient, m)
            return
        if isinstance(msg, dict):
            msg = &#34;\n&#34;.join((f&#34;{key}:\t{value}&#34; for key, value in msg.items()))
        json_command: JSON = {
            &#34;command&#34;: &#34;send&#34;,
            &#34;message&#34;: msg,
        }
        if endsession:
            json_command[&#34;endsession&#34;] = True
        if attachments:
            json_command[&#34;attachment&#34;] = attachments
        if group:
            json_command[&#34;group&#34;] = group
        elif recipient:
            try:
                assert recipient == utils.signal_format(recipient)
            except (AssertionError, NumberParseException) as e:
                logging.error(e)
                return
            json_command[&#34;recipient&#34;] = [str(recipient)]
        await self.signalcli_input_queue.put(json_command)
        return

    async def respond(self, target_msg: Message, msg: Union[str, list, dict]) -&gt; None:
        &#34;&#34;&#34;Respond to a message depending on whether it&#39;s a DM or group&#34;&#34;&#34;
        if target_msg.group:
            await self.send_message(None, msg, group=target_msg.group)
        else:
            await self.send_message(target_msg.source, msg)

    async def send_reaction(self, target_msg: Message, emoji: str) -&gt; None:
        &#34;&#34;&#34;Send a reaction. Protip: you can use e.g. \N{GRINNING FACE} in python&#34;&#34;&#34;
        react = {
            &#34;command&#34;: &#34;sendReaction&#34;,
            &#34;emoji&#34;: emoji,
            &#34;target-author&#34;: target_msg.source,
            &#34;target-timestamp&#34;: target_msg.timestamp,
        }
        if target_msg.group:
            react[&#34;group&#34;] = target_msg.group
        else:
            react[&#34;recipient&#34;] = [target_msg.source]
        await self.signalcli_input_queue.put(react)

    async def signalcli_input_iter(self) -&gt; AsyncIterator[dict]:
        &#34;&#34;&#34;Provides an asynchronous iterator over pending signal-cli commands&#34;&#34;&#34;
        while True:
            command = await self.signalcli_input_queue.get()
            yield command

    # maybe merge with the above?
    async def write_commands(self, pipe: StreamWriter) -&gt; None:
        &#34;&#34;&#34;Encode and write pending signal-cli commands&#34;&#34;&#34;
        async for msg in self.signalcli_input_iter():
            logging.info(&#34;input to signal: %s&#34;, msg)
            pipe.write(json.dumps(msg).encode() + b&#34;\n&#34;)


class Bot(Signal):
    &#34;&#34;&#34;Handles messages and command dispatch, as well as basic commands.
    Must be instantiated within a running async loop.
    Subclass this with your own commands.
    &#34;&#34;&#34;

    def __init__(self, *args: str) -&gt; None:
        &#34;&#34;&#34;Creates AND STARTS a bot that routes commands to do_x handlers&#34;&#34;&#34;
        self.client_session = aiohttp.ClientSession()
        self.mobster = payments_monitor.Mobster()
        super().__init__(*args)
        asyncio.create_task(self.start_process())
        asyncio.create_task(self.handle_messages())
        if utils.get_secret(&#34;MONITOR_WALLET&#34;):
            # currently spams and re-credits the same invoice each reboot
            asyncio.create_task(self.mobster.monitor_wallet())

    async def handle_messages(self) -&gt; None:
        &#34;&#34;&#34;Read messages from the queue and pass each message to handle_message
        If that returns a non-empty string, send it as a response&#34;&#34;&#34;
        async for message in self.signalcli_output_iter():
            # potentially stick a try-catch block here and send errors to admin
            response = await self.handle_message(message)
            if response:
                await self.respond(message, response)

    async def handle_message(self, message: Message) -&gt; Response:
        &#34;&#34;&#34;Method dispatch to do_x commands and goodies.
        Overwrite this to add your own non-command logic,
        but call super().handle_message(message) at the end&#34;&#34;&#34;
        if message.command:
            if hasattr(self, &#34;do_&#34; + message.command):
                return await getattr(self, &#34;do_&#34; + message.command)(message)
            suggest_help = &#34; Try /help.&#34; if hasattr(self, &#34;do_help&#34;) else &#34;&#34;
            return f&#34;Sorry! Command {message.command} not recognized!&#34; + suggest_help
        if message.text == &#34;TERMINATE&#34;:
            return &#34;signal session reset&#34;
        if message.text and not message.group:
            return &#34;That didn&#39;t look like a valid command&#34;
        if message.payment:
            return await self.handle_payment(message)
        return None

    async def do_help(self, message: Message) -&gt; str:
        &#34;&#34;&#34;List available commands. /help &lt;command&gt; gives you that command&#39;s documentation, if available&#34;&#34;&#34;
        if message.arg1:
            if hasattr(self, &#34;do_&#34; + message.arg1):
                cmd = getattr(self, &#34;do_&#34; + message.arg1)
                if cmd.__doc__:
                    return cmd.__doc__
                return f&#34;Sorry, {message.arg1} isn&#39;t documented&#34;
        # TODO: filter aliases and indicate which commands are undocumented
        return &#34;commands: &#34; + &#34;, &#34;.join(
            k.removeprefix(&#34;do_&#34;) for k in dir(self) if k.startswith(&#34;do_&#34;)
        )

    async def do_printerfact(self, _: Message) -&gt; str:
        &#34;Learn a fact about printers&#34;
        async with self.client_session.get(&#34;https://colbyolson.com/printers&#34;) as resp:
            fact = await resp.text()
        return fact.strip()

    async def do_ping(self, message: Message) -&gt; str:
        &#34;&#34;&#34;pong&#34;&#34;&#34;
        if message.text:
            return f&#34;pong {message.text}&#34;
        return &#34;pong&#34;

    async def check_target_number(self, msg: Message) -&gt; Optional[str]:
        &#34;&#34;&#34;Check if arg1 is a valid number. If it isn&#39;t, let the user know and return None&#34;&#34;&#34;
        try:
            logging.debug(&#34;checking %s&#34;, msg.arg1)
            assert msg.arg1
            parsed = pn.parse(msg.arg1, &#34;US&#34;)  # fixme: use PhoneNumberMatcher
            assert pn.is_valid_number(parsed)
            number = pn.format_number(parsed, pn.PhoneNumberFormat.E164)
            return number
        except (pn.phonenumberutil.NumberParseException, AssertionError):
            await self.send_message(
                msg.source,
                f&#34;{msg.arg1} doesn&#39;t look a valid number or user. &#34;
                &#34;did you include the country code?&#34;,
            )
            return None

    async def handle_payment(self, message: Message) -&gt; str:
        &#34;&#34;&#34;Decode the receipt, then update balances&#34;&#34;&#34;
        logging.info(message.payment)
        amount_pmob = await self.mobster.get_receipt_amount_pmob(
            message.payment[&#34;receipt&#34;]
        )
        if amount_pmob is None:
            return &#34;That looked like a payment, but we couldn&#39;t parse it&#34;
        amount_mob = mc_util.pmob2mob(amount_pmob)
        amount_usd_cents = round(amount_mob * await self.mobster.get_rate() * 100)
        self.mobster.ledger_manager.put_mob_tx(
            message.source,
            amount_usd_cents,
            amount_pmob,
            message.payment.get(&#34;note&#34;),
        )
        await self.respond(
            message,
            f&#34;Thank you for sending {amount_mob} MOB ({amount_usd_cents/100} USD)&#34;,
        )
        return await self.payment_response(message)

    async def payment_response(self, _: Message) -&gt; Response:
        return &#34;This bot doesn&#39;t have a response for payments.&#34;


async def no_get(request: web.Request) -&gt; web.Response:
    raise web.HTTPFound(location=&#34;https://signal.org/&#34;)


async def send_message_handler(request: web.Request) -&gt; web.Response:
    &#34;&#34;&#34;Allow webhooks to send messages to users.
    Turn this off, authenticate, or obfuscate in prod to someone from using your bot to spam people
    &#34;&#34;&#34;
    account = request.match_info.get(&#34;phonenumber&#34;)
    session = request.app.get(&#34;bot&#34;)
    if not session:
        return web.Response(status=504, text=&#34;Sorry, no live workers.&#34;)
    msg_data = await request.text()
    await session.send_message(
        account, msg_data, endsession=request.query.get(&#34;endsession&#34;)
    )
    return web.json_response({&#34;status&#34;: &#34;sent&#34;})


app = web.Application()

app.add_routes(
    [
        web.get(&#34;/&#34;, no_get),
        web.post(&#34;/user/{phonenumber}&#34;, send_message_handler),
    ]
)

if not utils.get_secret(&#34;NO_MEMFS&#34;):
    app.on_startup.append(datastore.start_memfs)
    app.on_startup.append(datastore.start_memfs_monitor)


if __name__ == &#34;__main__&#34;:

    @app.on_startup.append
    async def start_wrapper(out_app: web.Application) -&gt; None:
        out_app[&#34;bot&#34;] = Bot()

    web.run_app(app, port=8080, host=&#34;0.0.0.0&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="core.no_get"><code class="name flex">
<span>async def <span class="ident">no_get</span></span>(<span>request: aiohttp.web_request.Request) ‑> aiohttp.web_response.Response</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def no_get(request: web.Request) -&gt; web.Response:
    raise web.HTTPFound(location=&#34;https://signal.org/&#34;)</code></pre>
</details>
</dd>
<dt id="core.send_message_handler"><code class="name flex">
<span>async def <span class="ident">send_message_handler</span></span>(<span>request: aiohttp.web_request.Request) ‑> aiohttp.web_response.Response</span>
</code></dt>
<dd>
<div class="desc"><p>Allow webhooks to send messages to users.
Turn this off, authenticate, or obfuscate in prod to someone from using your bot to spam people</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_message_handler(request: web.Request) -&gt; web.Response:
    &#34;&#34;&#34;Allow webhooks to send messages to users.
    Turn this off, authenticate, or obfuscate in prod to someone from using your bot to spam people
    &#34;&#34;&#34;
    account = request.match_info.get(&#34;phonenumber&#34;)
    session = request.app.get(&#34;bot&#34;)
    if not session:
        return web.Response(status=504, text=&#34;Sorry, no live workers.&#34;)
    msg_data = await request.text()
    await session.send_message(
        account, msg_data, endsession=request.query.get(&#34;endsession&#34;)
    )
    return web.json_response({&#34;status&#34;: &#34;sent&#34;})</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="core.Message"><code class="flex name class">
<span>class <span class="ident">Message</span></span>
<span>(</span><span>blob: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a Message received from signal-cli, optionally
containing a command with arguments, group, quote, or payment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Message:
    &#34;&#34;&#34;Represents a Message received from signal-cli, optionally
    containing a command with arguments, group, quote, or payment&#34;&#34;&#34;

    def __init__(self, blob: dict) -&gt; None:
        self.blob = blob
        self.envelope = envelope = blob.get(&#34;envelope&#34;, {})
        # {&#39;envelope&#39;: {&#39;source&#39;: &#39;+15133278483&#39;, &#39;sourceDevice&#39;: 2, &#39;timestamp&#39;: 1621402445257, &#39;receiptMessage&#39;: {&#39;when&#39;: 1621402445257, &#39;isDelivery&#39;: True, &#39;isRead&#39;: False, &#39;timestamps&#39;: [1621402444517]}}}

        # envelope data
        self.source: str = envelope.get(&#34;source&#34;)
        self.name: str = envelope.get(&#34;sourceName&#34;) or self.source
        self.timestamp = envelope.get(&#34;timestamp&#34;)

        # msg data
        msg = envelope.get(&#34;dataMessage&#34;, {})
        self.full_text = self.text = msg.get(&#34;message&#34;, &#34;&#34;)
        self.group: Optional[str] = msg.get(&#34;groupInfo&#34;, {}).get(&#34;groupId&#34;)
        self.quoted_text = msg.get(&#34;quote&#34;, {}).get(&#34;text&#34;)
        self.payment = msg.get(&#34;payment&#34;)

        # parsing
        self.command: Optional[str] = None
        self.tokens: Optional[list[str]] = None
        if self.text and self.text.startswith(&#34;/&#34;):
            command, *self.tokens = self.text.split(&#34; &#34;)
            self.command = command[1:].lower()  # remove /
            self.arg1 = self.tokens[0] if self.tokens else None
            self.text = &#34; &#34;.join(self.tokens)
        # self.reactions: dict[str, str] = {}

    def __repr__(self) -&gt; str:
        # it might be nice to prune this so the logs are easier to read
        return f&#34;&lt;{self.envelope}&gt;&#34;</code></pre>
</details>
</dd>
<dt id="core.Signal"><code class="flex name class">
<span>class <span class="ident">Signal</span></span>
<span>(</span><span>bot_number: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a signal-cli session.
Lifecycle: Downloads the datastore, runs and restarts signal-cli,
tries to gracefully kill signal-cli and upload before exiting.
I/O: reads signal-cli's output into signalcli_output_queue,
has methods for sending commands to signal-cli, and
actually writes those json blobs to signal-cli's stdin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Signal:
    &#34;&#34;&#34;
    Represents a signal-cli session.
    Lifecycle: Downloads the datastore, runs and restarts signal-cli,
    tries to gracefully kill signal-cli and upload before exiting.
    I/O: reads signal-cli&#39;s output into signalcli_output_queue,
    has methods for sending commands to signal-cli, and
    actually writes those json blobs to signal-cli&#39;s stdin.
    &#34;&#34;&#34;

    def __init__(self, bot_number: Optional[str] = None) -&gt; None:
        if not bot_number:
            try:
                bot_number = utils.signal_format(sys.argv[1])
                assert bot_number is not None
            except IndexError:
                bot_number = utils.get_secret(&#34;BOT_NUMBER&#34;)
        logging.debug(&#34;bot number: %s&#34;, bot_number)
        self.bot_number = bot_number
        self.datastore = datastore.SignalDatastore(bot_number)
        self.proc: Optional[subprocess.Process] = None
        self.signalcli_output_queue: Queue[Message] = Queue()
        self.signalcli_input_queue: Queue[dict] = Queue()
        self.exiting = False

    async def start_process(self) -&gt; None:
        &#34;&#34;&#34;
        Add SIGINT handlers. Download datastore. Maybe set profile.
        (Re)start signal-cli and launch reading and writing with it.
        &#34;&#34;&#34;
        # things that don&#39;t work: loop.add_signal_handler(async_shutdown) - TypeError
        # signal.signal(sync_signal_handler) - can&#39;t interact with loop
        loop = asyncio.get_running_loop()
        loop.add_signal_handler(signal.SIGINT, self.sync_signal_handler)
        logging.debug(&#34;added signal handler, downloading...&#34;)
        if not utils.get_secret(&#34;NO_DOWNLOAD&#34;):
            await self.datastore.download()
        if utils.get_secret(&#34;PROFILE&#34;):
            await self.set_profile()
        while self.sigints == 0 and not self.exiting:
            command = f&#34;{utils.ROOT_DIR}/signal-cli --config {utils.ROOT_DIR} --output=json stdio&#34;.split()
            logging.info(command)
            self.proc = await asyncio.create_subprocess_exec(
                *command, stdin=PIPE, stdout=PIPE
            )
            logging.info(
                &#34;started signal-cli @ %s with PID %s&#34;,
                self.bot_number,
                self.proc.pid,
            )
            assert self.proc.stdout and self.proc.stdin
            asyncio.create_task(self.handle_signalcli_raw_output(self.proc.stdout))
            asyncio.create_task(self.write_commands(self.proc.stdin))
            returncode = await self.proc.wait()
            logging.warning(&#34;signal-cli exited: %s&#34;, returncode)
            if returncode == 0:
                logging.info(&#34;signal-cli apparently exited cleanly, not restarting&#34;)
                break

    sigints = 0

    def sync_signal_handler(self, *_: Any) -&gt; None:
        &#34;&#34;&#34;Try to start async_shutdown and/or just sys.exit&#34;&#34;&#34;
        logging.info(&#34;handling sigint. sigints: %s&#34;, self.sigints)
        self.sigints += 1
        self.exiting = True
        try:
            loop = asyncio.get_running_loop()
            logging.info(&#34;got running loop, scheduling async_shutdown&#34;)
            asyncio.run_coroutine_threadsafe(self.async_shutdown(), loop)
        except RuntimeError:
            asyncio.run(self.async_shutdown())
        if self.sigints &gt;= 3:
            sys.exit(1)

    async def async_shutdown(self, *_: Any, wait: bool = False) -&gt; None:
        &#34;&#34;&#34;Upload our datastore, close postgres connections pools, kill signal-cli, exit&#34;&#34;&#34;
        logging.info(&#34;starting async_shutdown&#34;)
        await self.datastore.upload()
        if self.proc:
            try:
                self.proc.kill()
                if wait:
                    await self.proc.wait()
                    await self.datastore.upload()
            except ProcessLookupError:
                logging.info(&#34;no signal-cli process&#34;)
        await self.datastore.mark_freed()
        await pghelp.close_pools()
        # this still deadlocks. see https://github.com/forestcontact/forest-draft/issues/10
        if datastore._memfs_process:
            executor = datastore._memfs_process._get_executor()
            logging.info(executor)
            executor.shutdown(wait=False, cancel_futures=True)
        logging.info(&#34;exited&#34;.center(60, &#34;=&#34;))
        sys.exit(0)
        logging.info(&#34;called sys.exit but still running, trying os._exit&#34;)
        os._exit(1)

    async def handle_signalcli_raw_output(self, stream: StreamReader) -&gt; None:
        &#34;&#34;&#34;Read signal-cli output but delegate handling it&#34;&#34;&#34;
        while True:
            line = (await stream.readline()).decode().strip()
            if not line:
                break
            await self.handle_signalcli_raw_line(line)
        logging.info(&#34;stopped reading signal-cli stdout&#34;)

    async def handle_signalcli_raw_line(self, line: str) -&gt; None:
        &#34;&#34;&#34;Try to parse a single line of signal-cli output. If it&#39;s a message, enqueue it&#34;&#34;&#34;
        # TODO: maybe output and color non-json. pretty-print errors
        # unrelatedly, try to sensibly color the other logging stuff like http logs
        # fly / db / asyncio and other lib warnings / java / signal logic and networking
        try:
            blob = json.loads(line)
        except json.JSONDecodeError:
            logging.info(&#34;signal: %s&#34;, line)
            return
        if not isinstance(blob, dict):  # e.g. a timestamp
            return
        if &#34;error&#34; in blob:
            if &#34;traceback&#34; in blob:
                exception, *tb = blob[&#34;traceback&#34;].split(&#34;\n&#34;)
                logging.error(termcolor.colored(exception, &#34;red&#34;))
                # maybe also send this to admin as a signal message
                for _line in tb:
                    logging.error(_line)
            else:
                logging.error(termcolor.colored(blob[&#34;error&#34;], &#34;red&#34;))
            return
        msg = Message(blob)
        if msg.full_text:  # and utils.get_secret(&#34;I_AM_NOT_A_FEDERAL_AGENT&#34;):
            logging.info(&#34;signal: %s&#34;, line)
        await self.signalcli_output_queue.put(msg)
        return

    # i&#39;m tempted to refactor these into handle_messages
    async def signalcli_output_iter(self) -&gt; AsyncIterator[Message]:
        &#34;&#34;&#34;Provides an asynchronous iterator over messages on the queue.
        See Bot for how messages and consumed and dispatched&#34;&#34;&#34;
        while True:
            message = await self.signalcli_output_queue.get()
            yield message

    # Next, we see how the input queue is populated and consumed.

    async def set_profile(self) -&gt; None:
        &#34;&#34;&#34;Set signal profile. Note that this will overwrite any mobilecoin address&#34;&#34;&#34;
        env = utils.get_secret(&#34;ENV&#34;)
        profile = {
            &#34;command&#34;: &#34;updateProfile&#34;,
            &#34;given-name&#34;: &#34;localbot&#34; if utils.LOCAL else &#34;forestbot&#34;,
            &#34;family-name&#34;: &#34;&#34; if env == &#34;prod&#34; else env,  # maybe not?
            &#34;avatar&#34;: &#34;avatar.png&#34;,
        }
        await self.signalcli_input_queue.put(profile)
        logging.info(profile)

    async def send_message(  # pylint: disable=too-many-arguments
        self,
        recipient: Optional[str],
        msg: Response,
        group: Optional[str] = None,  # maybe combine this with recipient?
        endsession: bool = False,
        attachments: Optional[list[str]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Builds send command with specified recipient and msg, writes to signal-cli.
        Prettyprints dict msgs, sends multiple messages for lists. Also does groups,
        attachments, and endsession&#34;&#34;&#34;
        if isinstance(msg, list):
            for m in msg:
                await self.send_message(recipient, m)
            return
        if isinstance(msg, dict):
            msg = &#34;\n&#34;.join((f&#34;{key}:\t{value}&#34; for key, value in msg.items()))
        json_command: JSON = {
            &#34;command&#34;: &#34;send&#34;,
            &#34;message&#34;: msg,
        }
        if endsession:
            json_command[&#34;endsession&#34;] = True
        if attachments:
            json_command[&#34;attachment&#34;] = attachments
        if group:
            json_command[&#34;group&#34;] = group
        elif recipient:
            try:
                assert recipient == utils.signal_format(recipient)
            except (AssertionError, NumberParseException) as e:
                logging.error(e)
                return
            json_command[&#34;recipient&#34;] = [str(recipient)]
        await self.signalcli_input_queue.put(json_command)
        return

    async def respond(self, target_msg: Message, msg: Union[str, list, dict]) -&gt; None:
        &#34;&#34;&#34;Respond to a message depending on whether it&#39;s a DM or group&#34;&#34;&#34;
        if target_msg.group:
            await self.send_message(None, msg, group=target_msg.group)
        else:
            await self.send_message(target_msg.source, msg)

    async def send_reaction(self, target_msg: Message, emoji: str) -&gt; None:
        &#34;&#34;&#34;Send a reaction. Protip: you can use e.g. \N{GRINNING FACE} in python&#34;&#34;&#34;
        react = {
            &#34;command&#34;: &#34;sendReaction&#34;,
            &#34;emoji&#34;: emoji,
            &#34;target-author&#34;: target_msg.source,
            &#34;target-timestamp&#34;: target_msg.timestamp,
        }
        if target_msg.group:
            react[&#34;group&#34;] = target_msg.group
        else:
            react[&#34;recipient&#34;] = [target_msg.source]
        await self.signalcli_input_queue.put(react)

    async def signalcli_input_iter(self) -&gt; AsyncIterator[dict]:
        &#34;&#34;&#34;Provides an asynchronous iterator over pending signal-cli commands&#34;&#34;&#34;
        while True:
            command = await self.signalcli_input_queue.get()
            yield command

    # maybe merge with the above?
    async def write_commands(self, pipe: StreamWriter) -&gt; None:
        &#34;&#34;&#34;Encode and write pending signal-cli commands&#34;&#34;&#34;
        async for msg in self.signalcli_input_iter():
            logging.info(&#34;input to signal: %s&#34;, msg)
            pipe.write(json.dumps(msg).encode() + b&#34;\n&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="core.Bot" href="#core.Bot">Bot</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="core.Signal.sigints"><code class="name">var <span class="ident">sigints</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="core.Signal.start_process"><code class="name flex">
<span>async def <span class="ident">start_process</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add SIGINT handlers. Download datastore. Maybe set profile.
(Re)start signal-cli and launch reading and writing with it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start_process(self) -&gt; None:
    &#34;&#34;&#34;
    Add SIGINT handlers. Download datastore. Maybe set profile.
    (Re)start signal-cli and launch reading and writing with it.
    &#34;&#34;&#34;
    # things that don&#39;t work: loop.add_signal_handler(async_shutdown) - TypeError
    # signal.signal(sync_signal_handler) - can&#39;t interact with loop
    loop = asyncio.get_running_loop()
    loop.add_signal_handler(signal.SIGINT, self.sync_signal_handler)
    logging.debug(&#34;added signal handler, downloading...&#34;)
    if not utils.get_secret(&#34;NO_DOWNLOAD&#34;):
        await self.datastore.download()
    if utils.get_secret(&#34;PROFILE&#34;):
        await self.set_profile()
    while self.sigints == 0 and not self.exiting:
        command = f&#34;{utils.ROOT_DIR}/signal-cli --config {utils.ROOT_DIR} --output=json stdio&#34;.split()
        logging.info(command)
        self.proc = await asyncio.create_subprocess_exec(
            *command, stdin=PIPE, stdout=PIPE
        )
        logging.info(
            &#34;started signal-cli @ %s with PID %s&#34;,
            self.bot_number,
            self.proc.pid,
        )
        assert self.proc.stdout and self.proc.stdin
        asyncio.create_task(self.handle_signalcli_raw_output(self.proc.stdout))
        asyncio.create_task(self.write_commands(self.proc.stdin))
        returncode = await self.proc.wait()
        logging.warning(&#34;signal-cli exited: %s&#34;, returncode)
        if returncode == 0:
            logging.info(&#34;signal-cli apparently exited cleanly, not restarting&#34;)
            break</code></pre>
</details>
</dd>
<dt id="core.Signal.sync_signal_handler"><code class="name flex">
<span>def <span class="ident">sync_signal_handler</span></span>(<span>self, *_: Any) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Try to start async_shutdown and/or just sys.exit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync_signal_handler(self, *_: Any) -&gt; None:
    &#34;&#34;&#34;Try to start async_shutdown and/or just sys.exit&#34;&#34;&#34;
    logging.info(&#34;handling sigint. sigints: %s&#34;, self.sigints)
    self.sigints += 1
    self.exiting = True
    try:
        loop = asyncio.get_running_loop()
        logging.info(&#34;got running loop, scheduling async_shutdown&#34;)
        asyncio.run_coroutine_threadsafe(self.async_shutdown(), loop)
    except RuntimeError:
        asyncio.run(self.async_shutdown())
    if self.sigints &gt;= 3:
        sys.exit(1)</code></pre>
</details>
</dd>
<dt id="core.Signal.async_shutdown"><code class="name flex">
<span>async def <span class="ident">async_shutdown</span></span>(<span>self, *_: Any, wait: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Upload our datastore, close postgres connections pools, kill signal-cli, exit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def async_shutdown(self, *_: Any, wait: bool = False) -&gt; None:
    &#34;&#34;&#34;Upload our datastore, close postgres connections pools, kill signal-cli, exit&#34;&#34;&#34;
    logging.info(&#34;starting async_shutdown&#34;)
    await self.datastore.upload()
    if self.proc:
        try:
            self.proc.kill()
            if wait:
                await self.proc.wait()
                await self.datastore.upload()
        except ProcessLookupError:
            logging.info(&#34;no signal-cli process&#34;)
    await self.datastore.mark_freed()
    await pghelp.close_pools()
    # this still deadlocks. see https://github.com/forestcontact/forest-draft/issues/10
    if datastore._memfs_process:
        executor = datastore._memfs_process._get_executor()
        logging.info(executor)
        executor.shutdown(wait=False, cancel_futures=True)
    logging.info(&#34;exited&#34;.center(60, &#34;=&#34;))
    sys.exit(0)
    logging.info(&#34;called sys.exit but still running, trying os._exit&#34;)
    os._exit(1)</code></pre>
</details>
</dd>
<dt id="core.Signal.handle_signalcli_raw_output"><code class="name flex">
<span>async def <span class="ident">handle_signalcli_raw_output</span></span>(<span>self, stream: asyncio.streams.StreamReader) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Read signal-cli output but delegate handling it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_signalcli_raw_output(self, stream: StreamReader) -&gt; None:
    &#34;&#34;&#34;Read signal-cli output but delegate handling it&#34;&#34;&#34;
    while True:
        line = (await stream.readline()).decode().strip()
        if not line:
            break
        await self.handle_signalcli_raw_line(line)
    logging.info(&#34;stopped reading signal-cli stdout&#34;)</code></pre>
</details>
</dd>
<dt id="core.Signal.handle_signalcli_raw_line"><code class="name flex">
<span>async def <span class="ident">handle_signalcli_raw_line</span></span>(<span>self, line: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Try to parse a single line of signal-cli output. If it's a message, enqueue it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_signalcli_raw_line(self, line: str) -&gt; None:
    &#34;&#34;&#34;Try to parse a single line of signal-cli output. If it&#39;s a message, enqueue it&#34;&#34;&#34;
    # TODO: maybe output and color non-json. pretty-print errors
    # unrelatedly, try to sensibly color the other logging stuff like http logs
    # fly / db / asyncio and other lib warnings / java / signal logic and networking
    try:
        blob = json.loads(line)
    except json.JSONDecodeError:
        logging.info(&#34;signal: %s&#34;, line)
        return
    if not isinstance(blob, dict):  # e.g. a timestamp
        return
    if &#34;error&#34; in blob:
        if &#34;traceback&#34; in blob:
            exception, *tb = blob[&#34;traceback&#34;].split(&#34;\n&#34;)
            logging.error(termcolor.colored(exception, &#34;red&#34;))
            # maybe also send this to admin as a signal message
            for _line in tb:
                logging.error(_line)
        else:
            logging.error(termcolor.colored(blob[&#34;error&#34;], &#34;red&#34;))
        return
    msg = Message(blob)
    if msg.full_text:  # and utils.get_secret(&#34;I_AM_NOT_A_FEDERAL_AGENT&#34;):
        logging.info(&#34;signal: %s&#34;, line)
    await self.signalcli_output_queue.put(msg)
    return</code></pre>
</details>
</dd>
<dt id="core.Signal.signalcli_output_iter"><code class="name flex">
<span>async def <span class="ident">signalcli_output_iter</span></span>(<span>self) ‑> AsyncIterator[<a title="core.Message" href="#core.Message">Message</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Provides an asynchronous iterator over messages on the queue.
See Bot for how messages and consumed and dispatched</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def signalcli_output_iter(self) -&gt; AsyncIterator[Message]:
    &#34;&#34;&#34;Provides an asynchronous iterator over messages on the queue.
    See Bot for how messages and consumed and dispatched&#34;&#34;&#34;
    while True:
        message = await self.signalcli_output_queue.get()
        yield message</code></pre>
</details>
</dd>
<dt id="core.Signal.set_profile"><code class="name flex">
<span>async def <span class="ident">set_profile</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set signal profile. Note that this will overwrite any mobilecoin address</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_profile(self) -&gt; None:
    &#34;&#34;&#34;Set signal profile. Note that this will overwrite any mobilecoin address&#34;&#34;&#34;
    env = utils.get_secret(&#34;ENV&#34;)
    profile = {
        &#34;command&#34;: &#34;updateProfile&#34;,
        &#34;given-name&#34;: &#34;localbot&#34; if utils.LOCAL else &#34;forestbot&#34;,
        &#34;family-name&#34;: &#34;&#34; if env == &#34;prod&#34; else env,  # maybe not?
        &#34;avatar&#34;: &#34;avatar.png&#34;,
    }
    await self.signalcli_input_queue.put(profile)
    logging.info(profile)</code></pre>
</details>
</dd>
<dt id="core.Signal.send_message"><code class="name flex">
<span>async def <span class="ident">send_message</span></span>(<span>self, recipient: Optional[str], msg: Union[str, list, dict[str, str], ForwardRef(None)], group: Optional[str] = None, endsession: bool = False, attachments: Optional[list] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Builds send command with specified recipient and msg, writes to signal-cli.
Prettyprints dict msgs, sends multiple messages for lists. Also does groups,
attachments, and endsession</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_message(  # pylint: disable=too-many-arguments
    self,
    recipient: Optional[str],
    msg: Response,
    group: Optional[str] = None,  # maybe combine this with recipient?
    endsession: bool = False,
    attachments: Optional[list[str]] = None,
) -&gt; None:
    &#34;&#34;&#34;Builds send command with specified recipient and msg, writes to signal-cli.
    Prettyprints dict msgs, sends multiple messages for lists. Also does groups,
    attachments, and endsession&#34;&#34;&#34;
    if isinstance(msg, list):
        for m in msg:
            await self.send_message(recipient, m)
        return
    if isinstance(msg, dict):
        msg = &#34;\n&#34;.join((f&#34;{key}:\t{value}&#34; for key, value in msg.items()))
    json_command: JSON = {
        &#34;command&#34;: &#34;send&#34;,
        &#34;message&#34;: msg,
    }
    if endsession:
        json_command[&#34;endsession&#34;] = True
    if attachments:
        json_command[&#34;attachment&#34;] = attachments
    if group:
        json_command[&#34;group&#34;] = group
    elif recipient:
        try:
            assert recipient == utils.signal_format(recipient)
        except (AssertionError, NumberParseException) as e:
            logging.error(e)
            return
        json_command[&#34;recipient&#34;] = [str(recipient)]
    await self.signalcli_input_queue.put(json_command)
    return</code></pre>
</details>
</dd>
<dt id="core.Signal.respond"><code class="name flex">
<span>async def <span class="ident">respond</span></span>(<span>self, target_msg: <a title="core.Message" href="#core.Message">Message</a>, msg: Union[str, list, dict]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Respond to a message depending on whether it's a DM or group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def respond(self, target_msg: Message, msg: Union[str, list, dict]) -&gt; None:
    &#34;&#34;&#34;Respond to a message depending on whether it&#39;s a DM or group&#34;&#34;&#34;
    if target_msg.group:
        await self.send_message(None, msg, group=target_msg.group)
    else:
        await self.send_message(target_msg.source, msg)</code></pre>
</details>
</dd>
<dt id="core.Signal.send_reaction"><code class="name flex">
<span>async def <span class="ident">send_reaction</span></span>(<span>self, target_msg: <a title="core.Message" href="#core.Message">Message</a>, emoji: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Send a reaction. Protip: you can use e.g. 😀 in python</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_reaction(self, target_msg: Message, emoji: str) -&gt; None:
    &#34;&#34;&#34;Send a reaction. Protip: you can use e.g. \N{GRINNING FACE} in python&#34;&#34;&#34;
    react = {
        &#34;command&#34;: &#34;sendReaction&#34;,
        &#34;emoji&#34;: emoji,
        &#34;target-author&#34;: target_msg.source,
        &#34;target-timestamp&#34;: target_msg.timestamp,
    }
    if target_msg.group:
        react[&#34;group&#34;] = target_msg.group
    else:
        react[&#34;recipient&#34;] = [target_msg.source]
    await self.signalcli_input_queue.put(react)</code></pre>
</details>
</dd>
<dt id="core.Signal.signalcli_input_iter"><code class="name flex">
<span>async def <span class="ident">signalcli_input_iter</span></span>(<span>self) ‑> AsyncIterator[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Provides an asynchronous iterator over pending signal-cli commands</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def signalcli_input_iter(self) -&gt; AsyncIterator[dict]:
    &#34;&#34;&#34;Provides an asynchronous iterator over pending signal-cli commands&#34;&#34;&#34;
    while True:
        command = await self.signalcli_input_queue.get()
        yield command</code></pre>
</details>
</dd>
<dt id="core.Signal.write_commands"><code class="name flex">
<span>async def <span class="ident">write_commands</span></span>(<span>self, pipe: asyncio.streams.StreamWriter) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Encode and write pending signal-cli commands</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def write_commands(self, pipe: StreamWriter) -&gt; None:
    &#34;&#34;&#34;Encode and write pending signal-cli commands&#34;&#34;&#34;
    async for msg in self.signalcli_input_iter():
        logging.info(&#34;input to signal: %s&#34;, msg)
        pipe.write(json.dumps(msg).encode() + b&#34;\n&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="core.Bot"><code class="flex name class">
<span>class <span class="ident">Bot</span></span>
<span>(</span><span>*args: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles messages and command dispatch, as well as basic commands.
Must be instantiated within a running async loop.
Subclass this with your own commands.</p>
<p>Creates AND STARTS a bot that routes commands to do_x handlers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bot(Signal):
    &#34;&#34;&#34;Handles messages and command dispatch, as well as basic commands.
    Must be instantiated within a running async loop.
    Subclass this with your own commands.
    &#34;&#34;&#34;

    def __init__(self, *args: str) -&gt; None:
        &#34;&#34;&#34;Creates AND STARTS a bot that routes commands to do_x handlers&#34;&#34;&#34;
        self.client_session = aiohttp.ClientSession()
        self.mobster = payments_monitor.Mobster()
        super().__init__(*args)
        asyncio.create_task(self.start_process())
        asyncio.create_task(self.handle_messages())
        if utils.get_secret(&#34;MONITOR_WALLET&#34;):
            # currently spams and re-credits the same invoice each reboot
            asyncio.create_task(self.mobster.monitor_wallet())

    async def handle_messages(self) -&gt; None:
        &#34;&#34;&#34;Read messages from the queue and pass each message to handle_message
        If that returns a non-empty string, send it as a response&#34;&#34;&#34;
        async for message in self.signalcli_output_iter():
            # potentially stick a try-catch block here and send errors to admin
            response = await self.handle_message(message)
            if response:
                await self.respond(message, response)

    async def handle_message(self, message: Message) -&gt; Response:
        &#34;&#34;&#34;Method dispatch to do_x commands and goodies.
        Overwrite this to add your own non-command logic,
        but call super().handle_message(message) at the end&#34;&#34;&#34;
        if message.command:
            if hasattr(self, &#34;do_&#34; + message.command):
                return await getattr(self, &#34;do_&#34; + message.command)(message)
            suggest_help = &#34; Try /help.&#34; if hasattr(self, &#34;do_help&#34;) else &#34;&#34;
            return f&#34;Sorry! Command {message.command} not recognized!&#34; + suggest_help
        if message.text == &#34;TERMINATE&#34;:
            return &#34;signal session reset&#34;
        if message.text and not message.group:
            return &#34;That didn&#39;t look like a valid command&#34;
        if message.payment:
            return await self.handle_payment(message)
        return None

    async def do_help(self, message: Message) -&gt; str:
        &#34;&#34;&#34;List available commands. /help &lt;command&gt; gives you that command&#39;s documentation, if available&#34;&#34;&#34;
        if message.arg1:
            if hasattr(self, &#34;do_&#34; + message.arg1):
                cmd = getattr(self, &#34;do_&#34; + message.arg1)
                if cmd.__doc__:
                    return cmd.__doc__
                return f&#34;Sorry, {message.arg1} isn&#39;t documented&#34;
        # TODO: filter aliases and indicate which commands are undocumented
        return &#34;commands: &#34; + &#34;, &#34;.join(
            k.removeprefix(&#34;do_&#34;) for k in dir(self) if k.startswith(&#34;do_&#34;)
        )

    async def do_printerfact(self, _: Message) -&gt; str:
        &#34;Learn a fact about printers&#34;
        async with self.client_session.get(&#34;https://colbyolson.com/printers&#34;) as resp:
            fact = await resp.text()
        return fact.strip()

    async def do_ping(self, message: Message) -&gt; str:
        &#34;&#34;&#34;pong&#34;&#34;&#34;
        if message.text:
            return f&#34;pong {message.text}&#34;
        return &#34;pong&#34;

    async def check_target_number(self, msg: Message) -&gt; Optional[str]:
        &#34;&#34;&#34;Check if arg1 is a valid number. If it isn&#39;t, let the user know and return None&#34;&#34;&#34;
        try:
            logging.debug(&#34;checking %s&#34;, msg.arg1)
            assert msg.arg1
            parsed = pn.parse(msg.arg1, &#34;US&#34;)  # fixme: use PhoneNumberMatcher
            assert pn.is_valid_number(parsed)
            number = pn.format_number(parsed, pn.PhoneNumberFormat.E164)
            return number
        except (pn.phonenumberutil.NumberParseException, AssertionError):
            await self.send_message(
                msg.source,
                f&#34;{msg.arg1} doesn&#39;t look a valid number or user. &#34;
                &#34;did you include the country code?&#34;,
            )
            return None

    async def handle_payment(self, message: Message) -&gt; str:
        &#34;&#34;&#34;Decode the receipt, then update balances&#34;&#34;&#34;
        logging.info(message.payment)
        amount_pmob = await self.mobster.get_receipt_amount_pmob(
            message.payment[&#34;receipt&#34;]
        )
        if amount_pmob is None:
            return &#34;That looked like a payment, but we couldn&#39;t parse it&#34;
        amount_mob = mc_util.pmob2mob(amount_pmob)
        amount_usd_cents = round(amount_mob * await self.mobster.get_rate() * 100)
        self.mobster.ledger_manager.put_mob_tx(
            message.source,
            amount_usd_cents,
            amount_pmob,
            message.payment.get(&#34;note&#34;),
        )
        await self.respond(
            message,
            f&#34;Thank you for sending {amount_mob} MOB ({amount_usd_cents/100} USD)&#34;,
        )
        return await self.payment_response(message)

    async def payment_response(self, _: Message) -&gt; Response:
        return &#34;This bot doesn&#39;t have a response for payments.&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="core.Signal" href="#core.Signal">Signal</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="core.Bot.handle_messages"><code class="name flex">
<span>async def <span class="ident">handle_messages</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Read messages from the queue and pass each message to handle_message
If that returns a non-empty string, send it as a response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_messages(self) -&gt; None:
    &#34;&#34;&#34;Read messages from the queue and pass each message to handle_message
    If that returns a non-empty string, send it as a response&#34;&#34;&#34;
    async for message in self.signalcli_output_iter():
        # potentially stick a try-catch block here and send errors to admin
        response = await self.handle_message(message)
        if response:
            await self.respond(message, response)</code></pre>
</details>
</dd>
<dt id="core.Bot.handle_message"><code class="name flex">
<span>async def <span class="ident">handle_message</span></span>(<span>self, message: <a title="core.Message" href="#core.Message">Message</a>) ‑> Union[str, list, dict[str, str], ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Method dispatch to do_x commands and goodies.
Overwrite this to add your own non-command logic,
but call super().handle_message(message) at the end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_message(self, message: Message) -&gt; Response:
    &#34;&#34;&#34;Method dispatch to do_x commands and goodies.
    Overwrite this to add your own non-command logic,
    but call super().handle_message(message) at the end&#34;&#34;&#34;
    if message.command:
        if hasattr(self, &#34;do_&#34; + message.command):
            return await getattr(self, &#34;do_&#34; + message.command)(message)
        suggest_help = &#34; Try /help.&#34; if hasattr(self, &#34;do_help&#34;) else &#34;&#34;
        return f&#34;Sorry! Command {message.command} not recognized!&#34; + suggest_help
    if message.text == &#34;TERMINATE&#34;:
        return &#34;signal session reset&#34;
    if message.text and not message.group:
        return &#34;That didn&#39;t look like a valid command&#34;
    if message.payment:
        return await self.handle_payment(message)
    return None</code></pre>
</details>
</dd>
<dt id="core.Bot.do_help"><code class="name flex">
<span>async def <span class="ident">do_help</span></span>(<span>self, message: <a title="core.Message" href="#core.Message">Message</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>List available commands. /help <command> gives you that command's documentation, if available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def do_help(self, message: Message) -&gt; str:
    &#34;&#34;&#34;List available commands. /help &lt;command&gt; gives you that command&#39;s documentation, if available&#34;&#34;&#34;
    if message.arg1:
        if hasattr(self, &#34;do_&#34; + message.arg1):
            cmd = getattr(self, &#34;do_&#34; + message.arg1)
            if cmd.__doc__:
                return cmd.__doc__
            return f&#34;Sorry, {message.arg1} isn&#39;t documented&#34;
    # TODO: filter aliases and indicate which commands are undocumented
    return &#34;commands: &#34; + &#34;, &#34;.join(
        k.removeprefix(&#34;do_&#34;) for k in dir(self) if k.startswith(&#34;do_&#34;)
    )</code></pre>
</details>
</dd>
<dt id="core.Bot.do_printerfact"><code class="name flex">
<span>async def <span class="ident">do_printerfact</span></span>(<span>self, _: <a title="core.Message" href="#core.Message">Message</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Learn a fact about printers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def do_printerfact(self, _: Message) -&gt; str:
    &#34;Learn a fact about printers&#34;
    async with self.client_session.get(&#34;https://colbyolson.com/printers&#34;) as resp:
        fact = await resp.text()
    return fact.strip()</code></pre>
</details>
</dd>
<dt id="core.Bot.do_ping"><code class="name flex">
<span>async def <span class="ident">do_ping</span></span>(<span>self, message: <a title="core.Message" href="#core.Message">Message</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>pong</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def do_ping(self, message: Message) -&gt; str:
    &#34;&#34;&#34;pong&#34;&#34;&#34;
    if message.text:
        return f&#34;pong {message.text}&#34;
    return &#34;pong&#34;</code></pre>
</details>
</dd>
<dt id="core.Bot.check_target_number"><code class="name flex">
<span>async def <span class="ident">check_target_number</span></span>(<span>self, msg: <a title="core.Message" href="#core.Message">Message</a>) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Check if arg1 is a valid number. If it isn't, let the user know and return None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_target_number(self, msg: Message) -&gt; Optional[str]:
    &#34;&#34;&#34;Check if arg1 is a valid number. If it isn&#39;t, let the user know and return None&#34;&#34;&#34;
    try:
        logging.debug(&#34;checking %s&#34;, msg.arg1)
        assert msg.arg1
        parsed = pn.parse(msg.arg1, &#34;US&#34;)  # fixme: use PhoneNumberMatcher
        assert pn.is_valid_number(parsed)
        number = pn.format_number(parsed, pn.PhoneNumberFormat.E164)
        return number
    except (pn.phonenumberutil.NumberParseException, AssertionError):
        await self.send_message(
            msg.source,
            f&#34;{msg.arg1} doesn&#39;t look a valid number or user. &#34;
            &#34;did you include the country code?&#34;,
        )
        return None</code></pre>
</details>
</dd>
<dt id="core.Bot.handle_payment"><code class="name flex">
<span>async def <span class="ident">handle_payment</span></span>(<span>self, message: <a title="core.Message" href="#core.Message">Message</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the receipt, then update balances</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def handle_payment(self, message: Message) -&gt; str:
    &#34;&#34;&#34;Decode the receipt, then update balances&#34;&#34;&#34;
    logging.info(message.payment)
    amount_pmob = await self.mobster.get_receipt_amount_pmob(
        message.payment[&#34;receipt&#34;]
    )
    if amount_pmob is None:
        return &#34;That looked like a payment, but we couldn&#39;t parse it&#34;
    amount_mob = mc_util.pmob2mob(amount_pmob)
    amount_usd_cents = round(amount_mob * await self.mobster.get_rate() * 100)
    self.mobster.ledger_manager.put_mob_tx(
        message.source,
        amount_usd_cents,
        amount_pmob,
        message.payment.get(&#34;note&#34;),
    )
    await self.respond(
        message,
        f&#34;Thank you for sending {amount_mob} MOB ({amount_usd_cents/100} USD)&#34;,
    )
    return await self.payment_response(message)</code></pre>
</details>
</dd>
<dt id="core.Bot.payment_response"><code class="name flex">
<span>async def <span class="ident">payment_response</span></span>(<span>self, _: <a title="core.Message" href="#core.Message">Message</a>) ‑> Union[str, list, dict[str, str], ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def payment_response(self, _: Message) -&gt; Response:
    return &#34;This bot doesn&#39;t have a response for payments.&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="core.Signal" href="#core.Signal">Signal</a></b></code>:
<ul class="hlist">
<li><code><a title="core.Signal.async_shutdown" href="#core.Signal.async_shutdown">async_shutdown</a></code></li>
<li><code><a title="core.Signal.handle_signalcli_raw_line" href="#core.Signal.handle_signalcli_raw_line">handle_signalcli_raw_line</a></code></li>
<li><code><a title="core.Signal.handle_signalcli_raw_output" href="#core.Signal.handle_signalcli_raw_output">handle_signalcli_raw_output</a></code></li>
<li><code><a title="core.Signal.respond" href="#core.Signal.respond">respond</a></code></li>
<li><code><a title="core.Signal.send_message" href="#core.Signal.send_message">send_message</a></code></li>
<li><code><a title="core.Signal.send_reaction" href="#core.Signal.send_reaction">send_reaction</a></code></li>
<li><code><a title="core.Signal.set_profile" href="#core.Signal.set_profile">set_profile</a></code></li>
<li><code><a title="core.Signal.signalcli_input_iter" href="#core.Signal.signalcli_input_iter">signalcli_input_iter</a></code></li>
<li><code><a title="core.Signal.signalcli_output_iter" href="#core.Signal.signalcli_output_iter">signalcli_output_iter</a></code></li>
<li><code><a title="core.Signal.start_process" href="#core.Signal.start_process">start_process</a></code></li>
<li><code><a title="core.Signal.sync_signal_handler" href="#core.Signal.sync_signal_handler">sync_signal_handler</a></code></li>
<li><code><a title="core.Signal.write_commands" href="#core.Signal.write_commands">write_commands</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="core.no_get" href="#core.no_get">no_get</a></code></li>
<li><code><a title="core.send_message_handler" href="#core.send_message_handler">send_message_handler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="core.Message" href="#core.Message">Message</a></code></h4>
</li>
<li>
<h4><code><a title="core.Signal" href="#core.Signal">Signal</a></code></h4>
<ul class="">
<li><code><a title="core.Signal.start_process" href="#core.Signal.start_process">start_process</a></code></li>
<li><code><a title="core.Signal.sync_signal_handler" href="#core.Signal.sync_signal_handler">sync_signal_handler</a></code></li>
<li><code><a title="core.Signal.async_shutdown" href="#core.Signal.async_shutdown">async_shutdown</a></code></li>
<li><code><a title="core.Signal.handle_signalcli_raw_output" href="#core.Signal.handle_signalcli_raw_output">handle_signalcli_raw_output</a></code></li>
<li><code><a title="core.Signal.handle_signalcli_raw_line" href="#core.Signal.handle_signalcli_raw_line">handle_signalcli_raw_line</a></code></li>
<li><code><a title="core.Signal.signalcli_output_iter" href="#core.Signal.signalcli_output_iter">signalcli_output_iter</a></code></li>
<li><code><a title="core.Signal.set_profile" href="#core.Signal.set_profile">set_profile</a></code></li>
<li><code><a title="core.Signal.send_message" href="#core.Signal.send_message">send_message</a></code></li>
<li><code><a title="core.Signal.respond" href="#core.Signal.respond">respond</a></code></li>
<li><code><a title="core.Signal.send_reaction" href="#core.Signal.send_reaction">send_reaction</a></code></li>
<li><code><a title="core.Signal.signalcli_input_iter" href="#core.Signal.signalcli_input_iter">signalcli_input_iter</a></code></li>
<li><code><a title="core.Signal.write_commands" href="#core.Signal.write_commands">write_commands</a></code></li>
<li><code><a title="core.Signal.sigints" href="#core.Signal.sigints">sigints</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="core.Bot" href="#core.Bot">Bot</a></code></h4>
<ul class="two-column">
<li><code><a title="core.Bot.handle_messages" href="#core.Bot.handle_messages">handle_messages</a></code></li>
<li><code><a title="core.Bot.handle_message" href="#core.Bot.handle_message">handle_message</a></code></li>
<li><code><a title="core.Bot.do_help" href="#core.Bot.do_help">do_help</a></code></li>
<li><code><a title="core.Bot.do_printerfact" href="#core.Bot.do_printerfact">do_printerfact</a></code></li>
<li><code><a title="core.Bot.do_ping" href="#core.Bot.do_ping">do_ping</a></code></li>
<li><code><a title="core.Bot.check_target_number" href="#core.Bot.check_target_number">check_target_number</a></code></li>
<li><code><a title="core.Bot.handle_payment" href="#core.Bot.handle_payment">handle_payment</a></code></li>
<li><code><a title="core.Bot.payment_response" href="#core.Bot.payment_response">payment_response</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>